<!DOCTYPE html>



  



<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">






  <meta name="keywords" content="C/C++,">










<meta name="description" content="16-宏 数组定义时，长度不能是变量，只能是常量值或者常量表达式（如通过# define 定义的常量，即宏定义）  有参宏 格式：#define 标示符(参数) 表达式，如#define S(a,b) a+b，则S(2,3) = 5  标示符与参数间不可有空格  有参宏展开时，只进行简单的替换，不进行计算，千万注意！！！">
<meta name="keywords" content="C&#x2F;C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C&#x2F;C++基础_02">
<meta property="og:url" content="http://21guns.top/2019/07/13/C:C++基础-02/index.html">
<meta property="og:site_name" content="Ry1ynn&#39;s blogs">
<meta property="og:description" content="16-宏 数组定义时，长度不能是变量，只能是常量值或者常量表达式（如通过# define 定义的常量，即宏定义）  有参宏 格式：#define 标示符(参数) 表达式，如#define S(a,b) a+b，则S(2,3) = 5  标示符与参数间不可有空格  有参宏展开时，只进行简单的替换，不进行计算，千万注意！！！">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://img.21guns.top/2019-07-08-062217.jpg">
<meta property="og:updated_time" content="2019-07-26T06:41:11.468Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C&#x2F;C++基础_02">
<meta name="twitter:description" content="16-宏 数组定义时，长度不能是变量，只能是常量值或者常量表达式（如通过# define 定义的常量，即宏定义）  有参宏 格式：#define 标示符(参数) 表达式，如#define S(a,b) a+b，则S(2,3) = 5  标示符与参数间不可有空格  有参宏展开时，只进行简单的替换，不进行计算，千万注意！！！">
<meta name="twitter:image" content="http://img.21guns.top/2019-07-08-062217.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://21guns.top/2019/07/13/C:C++基础-02/">





  <title>C/C++基础_02 | Ry1ynn's blogs</title>
  










</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ry1ynn's blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://21guns.top/2019/07/13/C:C++基础-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ry1ynn">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ry1ynn's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C/C++基础_02</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-13T07:41:03+08:00">
                2019-07-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-C/" itemprop="url" rel="index">
                    <span itemprop="name">C/C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="16-宏"><a href="#16-宏" class="headerlink" title="16-宏"></a>16-宏</h1><ul>
<li>数组定义时，长度不能是变量，只能是常量值或者常量表达式（如通过# define 定义的常量，即宏定义）</li>
</ul>
<h2 id="有参宏"><a href="#有参宏" class="headerlink" title="有参宏"></a>有参宏</h2><ul>
<li><p>格式：<code>#define 标示符(参数) 表达式</code>，如<code>#define S(a,b) a+b</code>，则<code>S(2,3) = 5</code></p>
</li>
<li><p>标示符与参数间不可有空格</p>
</li>
<li><p>有参宏展开时，只进行简单的替换，不进行计算，千万注意！！！<a id="more"></a>             </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> L(r) 2*r</span></span><br><span class="line">L(<span class="number">2</span>+<span class="number">3</span>)=<span class="number">2</span>*<span class="number">2</span>+<span class="number">3</span>=<span class="number">7</span>，而非<span class="number">2</span>*(<span class="number">2</span>+<span class="number">3</span>)=<span class="number">10</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>若要解决，在表达式中，将出现的参数扩起来，如<code>#define L(r) 2*(r)</code></li>
</ul>
<h2 id="两种include"><a href="#两种include" class="headerlink" title="两种include"></a>两种include</h2><ul>
<li><code>&quot;&quot;</code>编译器会先到当前目录下找这个头文件，如果找不到该头文件，会继续到系统目录下</li>
<li><code>&lt;&gt;</code>编译器会到系统目录下查找这个头文件，如果找不到该头文件，编译器报错，不会到当前目录下查找</li>
</ul>
<h1 id="17-函数"><a href="#17-函数" class="headerlink" title="17-函数"></a>17-函数</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>定义：函数可以把相对独立的某个功能抽象出来，使之成为程序中的一个独立实体。可以在程序中重复使用，以提高程序开发的效率</li>
<li>为何使用：函数使程序变得更简短，逻辑清晰，有利于程序维护</li>
</ul>
<h2 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h2><ul>
<li><p>形参</p>
<ul>
<li>定义函数时候的预设参数</li>
<li>规定了真正使用这个函数的时候，需要传递的数据类型</li>
</ul>
</li>
<li><p>实参</p>
<ul>
<li>调用函数时圆括号中的表达式</li>
<li>是传递给函数的参数</li>
</ul>
</li>
<li>函数内形参的改变不会影响实参<ul>
<li>因为形参与实参占用的是不同的内存空间</li>
<li>参数传递相当于用实参初始化了一个新的变量</li>
<li>形参相当于实参的一份拷贝，所以形参的改变，并不会导致实参也被改变</li>
</ul>
</li>
<li>函数定义——形参；函数调用——实参</li>
<li>形参与实参的数据类型应相同或赋值兼容（既可以完成类型转换）</li>
<li>实参可以是变量、常量、表达式、返回值（即要有具体的值）</li>
<li>形参生命周期：<ul>
<li>函数未调用：不占任何内存空间（有名无实</li>
<li>函数调用时：分配内存空间</li>
<li>函数调用完：内存空间被释放</li>
</ul>
</li>
<li>传递方向：形参到实参<ul>
<li>值传递：形参与实参是两个不同的内存单元，故本质上是两种不同的东西，改变形参的值，并不会改变实参的值</li>
<li>址传递：传递过去的是指针（即地址），这样形和实指向同一内存单元，可以修改值</li>
</ul>
</li>
</ul>
<h2 id="素（质）数判别"><a href="#素（质）数判别" class="headerlink" title="素（质）数判别"></a>素（质）数判别</h2><ul>
<li><p>法一：较直观，2～n-1 是否有n的因子（</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若性能要求不高，用这个足矣</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n<span class="number">-1</span>; i++)</span><br><span class="line">      <span class="keyword">if</span>(n%i == <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>法二：效率高，2～sqrt(n)是否有n的因子（数学知识别深究）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;		//sqrt()</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=<span class="built_in">sqrt</span>(n); i++)</span><br><span class="line">      <span class="keyword">if</span>(n%i == <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意：double sqrt(double x)，严格来讲是doubel</span></span><br><span class="line"><span class="comment">//上述代码，仅说明思路，不必纠结能否运行</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="18-变量类型"><a href="#18-变量类型" class="headerlink" title="18-变量类型"></a>18-变量类型</h1><h2 id="特殊变量特点"><a href="#特殊变量特点" class="headerlink" title="特殊变量特点"></a>特殊变量特点</h2><ul>
<li><p>const变量</p>
<ul>
<li>const型变量也是一种定义常量的手段</li>
<li>const型变量是特殊的变量，程序运行过程中不可改变，其他特性和变量一样</li>
<li>定义const变量时必须初始化</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a=<span class="number">100</span>;<span class="comment">//a不能被改变了</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b;        <span class="comment">//错误const的变量必须被初始化</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>static变量</p>
<ul>
<li><p>使用在全局变量之前-隐藏</p>
<ul>
<li>在全局变量之前，加上ー个 static，说明这个变量，仅仅在本文件中使用，</li>
<li>假如被定义为 static 的，在其他文件就无法通过extern 访问到了</li>
</ul>
</li>
<li><p>使用在局部变量之前-静态</p>
<ul>
<li>假如一个局部变量前面加上了 static，说明这个变量只会被初始化一次</li>
<li>每次离开函数的时候，还保留着当时的值。</li>
<li>再次进入函数的时候，值是上ー次留存下来的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ul>
<li>将变量常量化，const修饰过的变量不允许再次赋值</li>
<li><code>const int a 或 int const a</code>（在左在右均可，都修饰a的，与int同地位）</li>
<li>用 const 修饰的变量，无论是全局变量or局部变量，生存周期都是程序运行的整个过程</li>
<li>const常量与define常量的区别<ul>
<li>define是预处理，是宏，只会进行简单替换，并不会实际占内存</li>
<li>const是实实在在占内存的，是真实占空间的常量</li>
</ul>
</li>
</ul>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a><em>static</em></h2><ul>
<li>修饰局部变量，将其变为局部静态变量</li>
<li>静态变量特点<ul>
<li><strong>生存</strong>期为整个程序运行期</li>
<li>但在其作用域之外不能使用（生存期和作用域概念不同</li>
<li>若在函数内定义的同时进行了初始化，则不可再进行初始化（类似于const）</li>
</ul>
</li>
</ul>
<h2 id="全局-VS-局部变量"><a href="#全局-VS-局部变量" class="headerlink" title="全局 VS 局部变量"></a>全局 VS 局部变量</h2><ul>
<li>全局变量：<ul>
<li>定义在函数外部、对所有函数有效、作用范围是变量定义位置到<strong>程序结束位置</strong>（即本程序</li>
<li>定义在函数外部的变量，称之为全局变量，全局变量是被所有函数共享的</li>
</ul>
</li>
<li>局部变量：<ul>
<li>定义在函数内部、只对当前函数有效、作用范围是变量定义位置到<strong>函数结束位置</strong>（即本函数</li>
<li>定义在函数内部的变量，我们称之为局部变量。局部变量的作用范围（作用域）是在复合语句中</li>
</ul>
</li>
<li>重名时<ul>
<li>{}内，若全局与局部重名，则以局部为准，强龙不压地头蛇（之外，自然就是全局变量了，废话</li>
<li>当小作用域和大作用域中的变量重名的时候，小作用域的变量起作用</li>
</ul>
</li>
</ul>
<h2 id="静态、局部、全局变量比较"><a href="#静态、局部、全局变量比较" class="headerlink" title="静态、局部、全局变量比较"></a>静态、局部、全局变量比较</h2><ul>
<li>全局 VS 静态变量：静态变量类似于全局变量，所有的局部变量都为静态变量（静 &gt; 全</li>
<li>局部 VS 静态变量：局部变量 + static = 局部静态变量</li>
<li><p>静态变量</p>
<ul>
<li>全局变量：本身就是静态变量</li>
<li>局部变量：+static就变为静态变量</li>
<li>特点<ul>
<li><strong>生存</strong>期为整个程序运行期</li>
<li>但在其作用域之外不能使用（生存期和作用域概念不同</li>
<li>若在函数内定义的同时进行了初始化，则不可再进行初始化（类似于const）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="全局变量-amp-extern、static"><a href="#全局变量-amp-extern、static" class="headerlink" title="全局变量 &amp; extern、static"></a>全局变量 &amp; extern、static</h2><ul>
<li><p>若多个文件组成一个程序，如a文件与b文件，a文件中定义了全局变量，b文件若要引用，直接加extern即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//b文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> n;	<span class="comment">//n变量已在a文件定义</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>若a文件中定义的全局变量只想自己使用（不想共享给b），加static即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a文件</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> n;	<span class="comment">//n变量只限本文件使用</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>extern使用举例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.cpp</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, n);		<span class="comment">//打印出100</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="19-指针基础"><a href="#19-指针基础" class="headerlink" title="19-指针基础"></a>19-指针基础</h1><h2 id="指针、-、-amp"><a href="#指针、-、-amp" class="headerlink" title="指针、*、&amp;"></a>指针、*、&amp;</h2><ul>
<li><p>指针使用步骤</p>
<ol>
<li>定义指针变量</li>
<li>指针变量的赋值</li>
<li>指针解引用（即取内容</li>
</ol>
</li>
<li><p><code>*</code></p>
<ul>
<li>标示符，说明变量为指针变量</li>
<li>指针变量声明时用，<code>int * p</code></li>
<li><code>*p</code>：指针p指向的变量</li>
</ul>
</li>
<li><code>&amp;</code><ul>
<li>取地址符，获取变量的地址</li>
<li>指针变量赋值时用，<code>int * p = &amp;n</code></li>
<li><code>&amp;n</code>：变量n的地址</li>
</ul>
</li>
<li>小结<ul>
<li>对变量使用地址运算符（&amp;）可以取得变量的地址</li>
<li>对指针使用解引用运算符（*）可以获取储存在指针指向地址上的值</li>
<li>使用变量名称（标识符）直接获取变量存储的值</li>
</ul>
</li>
</ul>
<h2 id="指针指向其他类型变量？"><a href="#指针指向其他类型变量？" class="headerlink" title="指针指向其他类型变量？"></a>指针指向其他类型变量？</h2><ul>
<li><p>一个 int*类型的指针变量，不是只能存储int 型变量的地址</p>
</li>
<li><p>为何</p>
<ul>
<li>指针变量就是一个变量，里面存储的数据是任意的</li>
<li>指针会按照其类型使用它指向的那块内存区域，和内存中本身存储什么没有关系</li>
</ul>
</li>
<li><p>后果</p>
<ul>
<li><p>但是一个指针指向了和他类型不相符的地方，就容易发生访问越界的问题</p>
</li>
<li><p>不过一般情况下我们寻求的都是类型匹配，否则容易发生错误</p>
</li>
</ul>
</li>
</ul>
<h2 id="三个数字排序"><a href="#三个数字排序" class="headerlink" title="三个数字排序"></a>三个数字排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若想最终 x&gt;y&gt;z，则每个if条件都反着写大小关系，这样才能交换</span></span><br><span class="line"><span class="keyword">if</span>(x&lt;y)		<span class="comment">//使 x&gt;y</span></span><br><span class="line">    t=x;x=y;y=t;	<span class="comment">//借用中间变量来两变量互换</span></span><br><span class="line"><span class="keyword">if</span>(y&lt;z)		<span class="comment">//使 y&gt;z</span></span><br><span class="line">    t=y;y=z;z=t;</span><br><span class="line"><span class="keyword">if</span>(x&lt;z)		<span class="comment">//使 x&gt;z</span></span><br><span class="line">    t=x;x=y;y=t;</span><br><span class="line"><span class="comment">//最终x&gt;y&gt;z</span></span><br></pre></td></tr></table></figure>
<h1 id="20-VS相关"><a href="#20-VS相关" class="headerlink" title="20-VS相关"></a>20-VS相关</h1><h2 id="sizeof获取数组长度问题："><a href="#sizeof获取数组长度问题：" class="headerlink" title="sizeof获取数组长度问题："></a>sizeof获取数组长度问题：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sizeof数组名 除 sizeof数据类型</span></span><br><span class="line"><span class="keyword">int</span> nArr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, <span class="keyword">sizeof</span>(nArr));	<span class="comment">//为40，错误</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, <span class="keyword">sizeof</span>(nArr)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>) );	<span class="comment">//为10，正确</span></span><br></pre></td></tr></table></figure>
<h2 id="常见的两层循环思想："><a href="#常见的两层循环思想：" class="headerlink" title="常见的两层循环思想："></a>常见的两层循环思想：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)	<span class="comment">//注意j &lt;= i，惯用套路</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>, j);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  1</span></span><br><span class="line"><span class="comment">  1 2</span></span><br><span class="line"><span class="comment">  1 2 3</span></span><br><span class="line"><span class="comment">  1 2 3 4</span></span><br><span class="line"><span class="comment">  1 2 3 4 5</span></span><br><span class="line"><span class="comment">  1 2 3 4 5 6</span></span><br><span class="line"><span class="comment">  1 2 3 4 5 6 7</span></span><br><span class="line"><span class="comment">  1 2 3 4 5 6 7 8</span></span><br><span class="line"><span class="comment">  1 2 3 4 5 6 7 8 9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="VS-单步调试"><a href="#VS-单步调试" class="headerlink" title="VS 单步调试"></a>VS 单步调试</h2><ul>
<li>F10-单步步过调试</li>
<li>F11-单步步入调试</li>
</ul>
<h1 id="21-结构体-联合体-typedef"><a href="#21-结构体-联合体-typedef" class="headerlink" title="21-结构体-联合体-typedef"></a>21-结构体-联合体-typedef</h1><h2 id="如何处理各种数据"><a href="#如何处理各种数据" class="headerlink" title="如何处理各种数据"></a>如何处理各种数据</h2><ul>
<li>不变的数据：常量</li>
<li>变化的数据：变量</li>
<li>同类型的多个数据：数组</li>
<li>不同类型的多个数据：结构体</li>
</ul>
<h2 id="结构体定义的三种形式"><a href="#结构体定义的三种形式" class="headerlink" title="结构体定义的三种形式"></a>结构体定义的三种形式</h2><ul>
<li><p>初级：<strong>直接定义结构体变量</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 先定义好结构体变量，再用'.'连接成员变量名，来对成员赋值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  数据类型 成员变量名</span><br><span class="line">  ...</span><br><span class="line">&#125;结构体变量名;</span><br><span class="line">结构体变量名.成员变量名 = xxx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 在定义结构体变量的同时，用'&#123;&#125;'来对成员赋值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  数据类型 成员变量名;</span><br><span class="line">  ...</span><br><span class="line">&#125;结构体变量名 = &#123;成员值<span class="number">1</span>，成员值<span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>简便：<strong>先定义结构体类型，再定义结构体变量（常用</strong>，默认用这种</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体类型名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  数据类型 成员变量名</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> 结构体类型名 结构体变量名;</span></span><br><span class="line">结构体变量名.成员变量名 = xxx;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中间模式：<strong>定义结构体类型的同时定义结构体变量</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体类型名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  数据类型 成员变量名</span><br><span class="line">  ...</span><br><span class="line">&#125;结构体变量名;</span><br><span class="line"><span class="comment">//与初级形式类似，为成员赋值时也可有两种形式</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="定义结构体变量时struct写不写？"><a href="#定义结构体变量时struct写不写？" class="headerlink" title="定义结构体变量时struct写不写？"></a>定义结构体变量时struct写不写？</h2><ul>
<li>C语言编译器中，要写</li>
<li>C++编译器，可以不写</li>
<li>为了统一大业，C中定义结构体类型时，用typedef修饰一下，即重命名类型名，这样后面定义结构体变量时，C和C++都不用写struct</li>
</ul>
<h2 id="结构体与联合体"><a href="#结构体与联合体" class="headerlink" title="结构体与联合体"></a>结构体与联合体</h2><ul>
<li>结构体<ul>
<li>关键字：struct</li>
<li>所有成员拥有自己单独的内存空间</li>
</ul>
</li>
<li>联合体<ul>
<li>关键字：union</li>
<li>所有成员共享同一块内存空间</li>
</ul>
</li>
<li>二者的使用语法是一摸一样的</li>
</ul>
<h2 id="结构体变量的赋值"><a href="#结构体变量的赋值" class="headerlink" title="结构体变量的赋值"></a>结构体变量的赋值</h2><ul>
<li>全部成员赋值，<code>{}</code>的形式，<code>stu = {24,&quot;tom&quot;,&#39;80&#39;}</code></li>
<li>单个成员赋值，<code>.</code>点的形式，<code>stu.age = 24</code><ul>
<li>要注意，若成员是字符数组如<code>char name[20]</code>，用点的形式会失败，如<code>stu.name[20] = &quot;tom&quot;</code></li>
<li>要用<code>strcpy_s</code>来解决，<code>*strcpy_s*(stu.name,20,&quot;tom&quot;) ;</code></li>
</ul>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><p>字符常量用单引号，字符串常量用双引号</p>
</li>
<li><p>字符串的打印</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">"abcd"</span>;</span><br><span class="line"><span class="built_in">printf</span>(str); 	<span class="comment">//打印abcd，没有格式控制字符串，打印不了换行</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,str);		<span class="comment">//打印abcd，可传入变量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"abcd"</span>);		<span class="comment">//打印abcd，可直接传入字符串打印</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="22-堆空间与内存操作函数"><a href="#22-堆空间与内存操作函数" class="headerlink" title="22-堆空间与内存操作函数"></a>22-堆空间与内存操作函数</h1><h2 id="内存操作函数"><a href="#内存操作函数" class="headerlink" title="内存操作函数"></a>内存操作函数</h2><ul>
<li><p><code>malloc</code>：申请内存空间</p>
<ul>
<li><code>void* malloc(unsigned size)</code></li>
<li>以字节为单位申请一块内存空间，失败返回NULL</li>
<li>参数：要申请的大小（以字节为单位</li>
<li>返回值：申请成功后，空间的起始地址</li>
<li><code>int * p = (int *)malloc( sizeof(int) )</code>（告诉指针，这块内存空间的首地址和大小</li>
<li>注：起始地址和大小，如可以确定一块内存空间</li>
</ul>
</li>
<li><code>free</code>：释放内存空间</li>
<li><code>void free(void *memblock)</code><ul>
<li>释放动态申请的内存空间</li>
<li>参数为指向某块内存空间的指针</li>
<li><code>free(p)</code></li>
<li>注：指针指向这块内存空间，肯定就知道这块空间的首地址和大小</li>
</ul>
</li>
<li><p><code>memset</code>：初始化内存空间</p>
<ul>
<li><code>memset(首地址，要设置的值，要设置多大区域)</code></li>
<li>给刚申请的内存，设置一个初始值（不是给地址赋值，是给这个地址上的内容赋值</li>
</ul>
</li>
<li><code>memcpy</code>：拷贝内存空间中数据<ul>
<li><code>memcpy(des，src，要拷贝多大区域)</code></li>
<li>将一块内存中的数据拷贝到另一块内存中</li>
</ul>
</li>
</ul>
<h2 id="溢出与泄漏"><a href="#溢出与泄漏" class="headerlink" title="溢出与泄漏"></a>溢出与泄漏</h2><ul>
<li>溢出<ul>
<li>写入的数据超出了缓冲区的空间</li>
<li>比如：<code>int arr[10] = { 0 }; arr[10] = 10;</code></li>
</ul>
</li>
<li><p>泄露：</p>
<ul>
<li>没有释放从堆空间中申请的内存</li>
<li>比如：<code>while (true) malloc(sizeof(int));</code></li>
</ul>
</li>
<li><p>内存泄漏</p>
<ul>
<li>（暂将堆与动态内存同等看待）</li>
<li>堆，是需要自己释放的，如果使用结束后没有释放（这块内存就浪费了），造成内存泄漏</li>
<li>动态内存没有及时释放，并且指向他的指针指向了别处（没有人管他了，得不到利用，也浪费），也造成内存泄漏</li>
</ul>
</li>
<li>内存溢出<ul>
<li>用户在申请内存时，系统没有足够的内存供其使用，比如用户要8B的空间（因为有8B的数据要存储），而系统只给了4B，用户的8B数据再耗费了系统给的4B后，还不够，于是覆盖了其他正常数据</li>
<li>再比如，用scanf非安全版函数对数组进行赋值时，产生的数组越界问题</li>
</ul>
</li>
</ul>
<h2 id="堆与数组"><a href="#堆与数组" class="headerlink" title="堆与数组"></a>堆与数组</h2><ul>
<li>定义时长度或大小<ul>
<li>数组定义时，数组长度必须为常数（或常数表达式），大小是直接确定好的</li>
<li>而堆的大小，可以用变量，大小可以在程序运行过程中根据情况确定</li>
</ul>
</li>
<li>释放问题<ul>
<li>堆，需要自己释放内存空间，若不释放，造成内存泄漏</li>
<li>数组，程序结束后，内存空间自动释放</li>
</ul>
</li>
</ul>
<h2 id="堆与栈"><a href="#堆与栈" class="headerlink" title="堆与栈"></a>堆与栈</h2><ul>
<li>运行时的程序，内存分为五个区域：代码区、常量区、栈区、堆区、全局变量区</li>
<li>栈区：<ul>
<li>存放局部变量</li>
<li>由系统自动分配</li>
<li>类似去饭馆里吃饭，只管点菜、付钱、和吃，不必理会其他工作，他的好处是</li>
<li>快捷，但是自由度小</li>
</ul>
</li>
<li>堆区：<ul>
<li>malloc出来的</li>
<li>用户手动申请的</li>
<li>类似自己动手做饭，要做洗菜等乱七八糟的工作，但是饭菜符合自己口味</li>
<li>比较麻烦，但是自由度大</li>
</ul>
</li>
</ul>
<h2 id="悬空指针与野指针"><a href="#悬空指针与野指针" class="headerlink" title="悬空指针与野指针"></a>悬空指针与野指针</h2><ul>
<li>悬空指针：<ul>
<li>内存被释放后，相应的指针应及时赋值为NULL</li>
<li>若不赋值为NULL，没得指了，就成了悬空指针</li>
</ul>
</li>
<li>野指针：指针变量被定义后，没有赋值，就是野指针</li>
<li>二者都是没得指，悬空指针曾经指过，野指针都没指过</li>
</ul>
<h2 id="使用原则、注意事项"><a href="#使用原则、注意事项" class="headerlink" title="使用原则、注意事项"></a>使用原则、注意事项</h2><ul>
<li>分配后的内存空间，其内存放的数据是一些乱七八糟的值，要及时为其赋值</li>
<li>不可对同一指针（地址）连续进行free操作（一次就好～</li>
<li>free针对的是堆区这一块内存区域，其他的如存放局部变量的栈区和存放全局变量、静态局部变量的全局数据区，不可进行free操作</li>
<li>如果对某指针/地址进行了free 操作，仅代表他指向的内存空间被回收了，但是他脑子里依然记得那块空间的地址（痴情狗），如果不及时赋值为NULL，就变成悬空指针（要喝忘情水的）</li>
<li>执行malloc和free有一定代价，要尽量避免频繁的申请与释放内存（故小数据量就不用麻烦他们了，因为大数据可能弄一次就好了，小数据繁琐至极，可能要弄多次）</li>
</ul>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><ul>
<li><p>字符串分配动态空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str1 = <span class="string">"Hello 15PB!"</span>;</span><br><span class="line"><span class="keyword">char</span> *str2 = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(str1));</span><br><span class="line"><span class="built_in">strcpy</span>(str2, str1);</span><br><span class="line"><span class="comment">//可能会报错，因为在申请堆空间时时stlen没有考虑到空字符('\0')，导致目标空间过小，引发溢出异常，可改为以下形式</span></span><br><span class="line"><span class="comment">//char *str2 = (char *)malloc(strlen(str1) + 1);</span></span><br><span class="line"><span class="comment">//strcpy_s(str2, strlen(str1) + 1, str1);</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="23-运行期内存、变量生存期"><a href="#23-运行期内存、变量生存期" class="headerlink" title="23-运行期内存、变量生存期"></a>23-运行期内存、变量生存期</h1><h2 id="运行期内存"><a href="#运行期内存" class="headerlink" title="运行期内存"></a>运行期内存</h2><ul>
<li>运行时的程序，内存分为五个区域：代码区、常量区、栈区、堆区、全局变量区<ul>
<li>代码区：代码本身也是数据，也要占内存</li>
<li>常量区：字符串等常量</li>
<li>栈区：局部变量、函数参数</li>
<li>堆区：程序员自己通过 malloc 申请出来的内存都在堆区</li>
<li>全局数据区：全局变量、静态局部变量</li>
</ul>
</li>
<li>注意：生存期与作用域是两个不同概念，时间与空间</li>
</ul>
<h2 id="不同类型变量的生存期与作用域"><a href="#不同类型变量的生存期与作用域" class="headerlink" title="不同类型变量的生存期与作用域"></a>不同类型变量的生存期与作用域</h2><ul>
<li>普通局部变量：二者都是 在一个<code>{}</code>内</li>
<li>静态局部变量：<ul>
<li>生存期：从定义到程序结束</li>
<li>作用域：在一个<code>{}</code>内</li>
</ul>
</li>
<li>全局变量：二者都是 从变量定义到程序结束</li>
<li>const修饰的变量：<ul>
<li>生存期：其修饰的变量，无论是全局变量or局部变量，生存周期都是程序运行的整个过程</li>
<li>作用域：这要看其修饰的是全局变量还是局部变量了</li>
</ul>
</li>
<li>static修饰的变量（目前只接触到静态局部变量<ul>
<li>生存期：从变量定义到程序结束（从这个角度看，跟const一个样</li>
<li>作用域：在一个<code>{}</code>内（废话</li>
</ul>
</li>
</ul>
<h1 id="24-指针进阶"><a href="#24-指针进阶" class="headerlink" title="24-指针进阶"></a>24-指针进阶</h1><p>PS:第一次整理，好多说话不严谨，后续再理解</p>
<h2 id="strlen-、sizeof-、-countof"><a href="#strlen-、sizeof-、-countof" class="headerlink" title="strlen()、sizeof()、_countof()"></a>strlen()、sizeof()、_countof()</h2><ul>
<li><p>三者区别</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> String[] = &#123; <span class="string">"123456789"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sizeof: 运算符，以字节为单位返回运算对象的大小</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(Array) = %zd\n"</span>, <span class="keyword">sizeof</span>(String));   <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//strlen: 库函数，用于获取船投入字符串的字符数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"strlen(Array) = %zd\n"</span>, <span class="built_in">strlen</span>(String));   <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//_countof: 有参宏，返回数组元素的个数</span></span><br><span class="line"><span class="comment">//定义为: #define _countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"_countof(Array)=%zd\n"</span>,_countof(String)); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>strlen</code>：</p>
<ul>
<li>函数</li>
<li>求字符串长度（不包含最后的0</li>
<li><code>string.h</code>头文件中</li>
</ul>
</li>
<li><p><code>sizeof</code>：</p>
<ul>
<li>运算符</li>
<li>求数组所占了多少字节（而非元素</li>
<li><code>stdio.h</code>头文件中</li>
</ul>
</li>
<li><p>_countof：</p>
<ul>
<li>宏</li>
<li>求数组中包含了多少元素</li>
<li><code>stdlib.h</code>头文件中</li>
</ul>
</li>
<li><p>举例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nArr[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> cArr[] = <span class="string">"abcd"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">sizeof</span>(nArr));		<span class="comment">//20，5个元素，每个占4B</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, _countof(nArr));		<span class="comment">//5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">strlen</span>(cArr));		<span class="comment">//4，不包括最后的0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="数组退化为指针"><a href="#数组退化为指针" class="headerlink" title="数组退化为指针"></a>数组退化为指针</h2><ul>
<li><p>向函数中传入数组时，数组会退化为指针，有一些用于计算长度的方法，会不同于我们的预期</p>
</li>
<li><p>因为数组名是该数组元素的首地址<code>Array==&amp;Array[0]</code>，作为实参传递的数组名要求形参是一个与之匹配的指针(指向数组元素的指针)，所以形参的实际大小是指向元素的指针大小，举例如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(<span class="keyword">int</span> Array[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Func(): sizeof(Array) = %zd\n"</span>, <span class="keyword">sizeof</span>(Array));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Array[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"main(): sizeof(Array) = %zd\n"</span>, <span class="keyword">sizeof</span>(Array));</span><br><span class="line">	Func(Array);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Func(): sizeof(Array) = 4</span></span><br><span class="line"><span class="comment">//main(): sizeof(Array) = 40</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>得到正常的数组长度</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nArr[<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> nLen = <span class="number">0</span>;</span><br><span class="line">	nLen = <span class="keyword">sizeof</span>(nArr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"this array's length is:%d\n"</span>, nLen); <span class="comment">//输出3，正常</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>若将数组名传入函数，利用函数来计算长度，长度会计算错误</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetArrLen</span><span class="params">(<span class="keyword">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">sizeof</span>(p) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);<span class="comment">// 4/4=1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nArr[<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> nLen = <span class="number">0</span>;</span><br><span class="line">	nLen = GetArrLen(nArr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"this array's length is:%d\n"</span>, nLen);	<span class="comment">//1，长度错误</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指针变量说到底，本质上也是一个变量，占4个字节的空间</p>
<ul>
<li>32位计算机（其实是C编译器的位数来决定）中占4B，64位中占8B，占几个字节取决于地址有多少位</li>
<li><code>sizeof(p) / sizeof(int); 即4/4=1</code></li>
</ul>
</li>
</ul>
<h2 id="指针形式字符串与数组形式字符串"><a href="#指针形式字符串与数组形式字符串" class="headerlink" title="指针形式字符串与数组形式字符串"></a>指针形式字符串与数组形式字符串</h2><ul>
<li><p>指针形式：<code>char *p1 = (char*)&quot;Hello15PB&quot;;</code></p>
<ul>
<li>指针p1是一个变量<ul>
<li>存储于栈区</li>
<li>p1是变量，故其可以存其他变量地址，即可以指向其他变量；</li>
</ul>
</li>
<li>字符串是一个字符串常量<ul>
<li>存储于常量区</li>
<li>是常量，故无法更改</li>
</ul>
</li>
</ul>
</li>
<li><p>数组形式：<code>char p2[] = &quot;Hello15PB&quot;;</code></p>
<ul>
<li>p2是数组名，其指向字符串的首地址，是一个指针常量，无法再指向其他</li>
<li>后面的字符串是一个个字符存进去的，不是一个常量，可以更改</li>
</ul>
</li>
<li><p>总而言之：</p>
<ul>
<li><p>指针形式的字符串，字符串是常量，存储在内存的常量区</p>
</li>
<li><p>数组形式的字符串，字符串是变量，存储在内存的栈区</p>
</li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li>二者不管是什么形式，字符串后面都会有<code>\0</code></li>
<li>常量在单步调试时，在内存窗口，无法看到其在内存的变化，而变量可以</li>
</ul>
</li>
<li><p>二者区别</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p1 = (<span class="keyword">char</span>*)<span class="string">"Hello15PB"</span>;</span><br><span class="line"><span class="keyword">char</span> p2[] = <span class="string">"Hello15PB"</span>;</span><br><span class="line"></span><br><span class="line">p1是一个指针，p2是一个数组，详细区别如下</span><br><span class="line"><span class="keyword">char</span> *p1 = (<span class="keyword">char</span>*)<span class="string">"Hello15PB"</span>;</span><br><span class="line"><span class="comment">// p1 是一个指针，指向了常量字符串"Hello15PB"，sizeof(p1) == 4</span></span><br><span class="line"><span class="comment">// p1 所指像的字符串内容是无法修改的,即 p1[0] = ‘1’; 会出现错误</span></span><br><span class="line"><span class="keyword">char</span> p2[] = <span class="string">"Hello15PB"</span>;</span><br><span class="line"><span class="comment">// p2 是一个字符数组，有10个元素，存储了字符串"Hello15PB"，sizeof(p2) == 10</span></span><br><span class="line"><span class="comment">// 因为p2 是一个非常量数组，所以p2的内容可变, p2[0] = ‘1’ 改变了第一个字符</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><ul>
<li><p>函数指针是指向函数的指针变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数指针</span></span><br><span class="line"><span class="keyword">int</span> (* p)(<span class="keyword">int</span>, <span class="keyword">int</span>) = &amp; max;<span class="comment">//&amp;可以省略；其定义要与函数对应（参数、返回值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数指针可以像一般函数一样，用于调用函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">max(a,b)	<span class="comment">//一般形式调用</span></span><br><span class="line">p(a,b)	<span class="comment">//用函数指针调用，除了名字不同外，其他无异</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数指针可以像普通变量一样，将自己作为参数，传递给其他函数使用</p>
<ul>
<li>回调函数就是一个通过函数指针调用的函数（没用到，暂不深究</li>
</ul>
</li>
</ul>
<h2 id="指针占了多少空间？"><a href="#指针占了多少空间？" class="headerlink" title="指针占了多少空间？"></a>指针占了多少空间？</h2><ul>
<li><p>字符、浮点数、函数指针</p>
<ul>
<li>三种类型的指针变量所占内存相同，在32位机器中，上面的指针都占4字节大小</li>
<li>指针的长度与当前CPU的寻址长度和编译器的位数有关</li>
<li>例如在64位机器中使用32位编译器进行编译，指针大小为4字节</li>
<li>在相同的机器中，使用64位编译器进行编译，指针的长度为8字节</li>
</ul>
</li>
<li><p>指针变量，说到家，本质上也是一个变量</p>
</li>
<li>不管指向整型、浮点型，还是函数（函数存放在内存中代码区），指针内都存放了其地址，都是4个字节</li>
<li>计算机（C编译器）的位数，决定了地址用多少位来表示，也就确定了指针占几个字节</li>
</ul>
<h2 id="野指针、悬空指针"><a href="#野指针、悬空指针" class="headerlink" title="野指针、悬空指针"></a>野指针、悬空指针</h2><ul>
<li><p>野指针：指向一个无效地址的指针(未初始化)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p; <span class="comment">// p是一个野指针，指向位置的内存空间</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>悬空指针：指向一片已经被释放的空间的指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">// 此时p是一个悬空指针</span></span><br><span class="line">p = <span class="literal">NULL</span>;<span class="comment">// 释放后将 p 置为空</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="数组传参"><a href="#数组传参" class="headerlink" title="数组传参"></a>数组传参</h2><ul>
<li>一维数组作为参数传递，形参可以是<ul>
<li>一级指针</li>
<li>一维数组</li>
</ul>
</li>
<li>二维数组作为参数传递，形参可以是：<ul>
<li>二维数组（第一个下标可以没有，第二个必须有</li>
<li>数组指针，如<code>int (*p)[5]</code></li>
</ul>
</li>
</ul>
<h2 id="指针与一维数组"><a href="#指针与一维数组" class="headerlink" title="指针与一维数组"></a>指针与一维数组</h2><ul>
<li><p>数组名</p>
<ul>
<li>是数组的起始地址</li>
<li>也是数组第一个元素的地址</li>
<li>是一个指针常量，是常量，没法再指向别人</li>
</ul>
</li>
<li><p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> * p = &amp;a;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重点理解记忆：</p>
<ul>
<li>p与a均是指针，前者是指针变量，后者是指针常量，二者指向同一块内存空间</li>
<li>某种程度上可认为：a就是p！！！</li>
<li><code>a+2 与 &amp;a[2]</code>等价，同理<code>p+2 与 &amp;p[2]</code>等价，四者都指向第三个元素的地址</li>
<li>地址加<code>*</code>解引用，就是取数据，即<code>*(a+2)、*&amp;a[2]、*(p+2)、*&amp;p[2]</code>四者等价，都是第三个元素a[2]</li>
<li><code>*&amp;a[2]、*&amp;p[2]</code>都表数据，<code>*&amp;</code>有点抵消的感觉</li>
<li>记住：<code>a[i] = *(a+i)</code></li>
</ul>
</li>
</ul>
<h2 id="指针与二维数组"><a href="#指针与二维数组" class="headerlink" title="指针与二维数组"></a>指针与二维数组</h2><ul>
<li><p>二维数组名</p>
<ul>
<li>也是一个指针</li>
<li>叫一维数组指针，即所谓的数组指针</li>
</ul>
</li>
<li><p>数组指针：</p>
<ul>
<li>指向数组的指针</li>
<li>二维数组名叫一维数组指针，即指向的数组是一维的</li>
</ul>
</li>
<li><p>数组指针的定义</p>
<ul>
<li><code>int (*p) [4]</code>，即<code>类型名 (* 指针变量名) [数组长度]</code></li>
<li>p的类型为：<code>int (*) [4]</code></li>
<li>4：指针p指向的数组有四个元素</li>
<li>数组指针定义时，一定要给出数组的长度</li>
</ul>
</li>
<li><p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> (*p) [<span class="number">4</span>];</span><br><span class="line">p = a;<span class="comment">//a和p类型：都是int * [4]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重点理解记忆：</p>
<ul>
<li><code>a[i]与*(a+i)</code>等价，都是<code>第i行第0列</code>的元素</li>
<li><code>a[i]+j、*(a+i)+j、&amp;a[0][0]+4*i+j</code>，都是<code>第i行第j列</code>元素</li>
<li>对于一维数组<code>int a[3]</code>，<code>&amp;a</code>的数据类型为<code>int (*)[3]</code>，也就是一维数组指针，也就验证了，数组指针就是指向数组的指针，a保存数组的地址，&amp;a保存a的地址</li>
</ul>
</li>
<li><p>指针与多维数组同理，类比一下</p>
</li>
</ul>
<h2 id="指针与二维数组画图理解"><a href="#指针与二维数组画图理解" class="headerlink" title="指针与二维数组画图理解"></a>指针与二维数组画图理解</h2><ul>
<li><p>代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> (*p) [<span class="number">4</span>];</span><br><span class="line">p =a;</span><br></pre></td></tr></table></figure>
</li>
<li><p>图画：</p>
<p><img src="http://img.21guns.top/2019-07-08-062217.jpg" alt></p>
</li>
</ul>
<h2 id="数组指针与指针数组"><a href="#数组指针与指针数组" class="headerlink" title="数组指针与指针数组"></a>数组指针与指针数组</h2><ul>
<li>数组指针，如上述<strong>指针与一维数组</strong>所讲，就是指向数组的指针</li>
<li>指针数组，就是保存了许多指针的数组，每一个元素都是指针变量</li>
<li>定义指针数组<ul>
<li>数据类型 * 指针变量名 [数组长度]</li>
<li><code>int * p[4]</code></li>
</ul>
</li>
<li>注意区分：<code>int * p[4]</code>与 <code>int (*p) [4]</code> </li>
<li>指针数组与二维数组的区别：前者存指针，后者存数据</li>
</ul>
<h2 id="指针分级"><a href="#指针分级" class="headerlink" title="指针分级"></a>指针分级</h2><ul>
<li>普通变量取地址，得一级指针（类似一维数组名，类似而非等于，还是有点差别</li>
<li>指针取地址，即指针的指针，得二级指针（类似二维数组名，其又称一维数组指针，指针指向数组，而数组又是一地址，类似而非等于，还是有点差别）</li>
<li>一维数组作为参数传递：形参可以是一级指针、一维数组</li>
<li>同理，二维数组作为参数传递：形参可以是数组指针、二维数组</li>
</ul>
<h2 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h2><ul>
<li><p>对于一个日期，如2019.07.06，没必要费劲提取年月日、字符串转数字，仅在输入时利用scanf_s就可（注意：针对的是从控制台现输入的日期）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scanf_s(<span class="string">"%d"</span>, &amp;nYear1);</span><br><span class="line">scanf_s(<span class="string">"%c"</span>, &amp;cTmp1,<span class="number">1</span>);</span><br><span class="line">scanf_s(<span class="string">"%d"</span>, &amp;nMonth1);</span><br><span class="line">scanf_s(<span class="string">"%c"</span>, &amp;cTmp2,<span class="number">1</span>);</span><br><span class="line">scanf_s(<span class="string">"%d"</span>, &amp;nDay1);</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算两个日期隔了多少天，转换思路，分别计算从0001年1月1日，两日期分别过了多少天，再相减（利用时间戳的思想）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个日期：从0001年1月1日到现在共过了多少天</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nYear1; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> ((i % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; i % <span class="number">100</span> != <span class="number">0</span>) || (i % <span class="number">400</span> == <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		nSumDays1 += <span class="number">366</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		nSumDays1 += <span class="number">365</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nMonth1; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (i)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">		nSumDays1 += <span class="number">31</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">		nSumDays1 += <span class="number">30</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">if</span> ((nYear1 % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; nYear1 % <span class="number">100</span> != <span class="number">0</span>) || (nYear1 % <span class="number">400</span> == <span class="number">0</span>))</span><br><span class="line">			nSumDays1 += <span class="number">29</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			nSumDays1 += <span class="number">28</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">nSumDays1 += nDay1;<span class="comment">//第一次搞错，此语句放在了上面的&#123;&#125;内，今后一定避免！！！！</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关于switch-case</p>
<ul>
<li>多个case可以共用同一块语句（如上</li>
<li>case下属的代码块可以像python风格一样，用冒号和缩进控制（如果不确定，用{}万无一失</li>
<li>一定不要遗漏break！！！</li>
</ul>
</li>
</ul>
<h1 id="25-文件操作"><a href="#25-文件操作" class="headerlink" title="25-文件操作"></a>25-文件操作</h1><h2 id="C中文件分类"><a href="#C中文件分类" class="headerlink" title="C中文件分类"></a>C中文件分类</h2><ul>
<li>按ASCII码存放：<ul>
<li>称为ASCII文件或文本(text)文件</li>
<li>文件中的字节与实际字符一一对应</li>
<li>优：方便字符处理和用户阅读</li>
<li>缺：占空间大、字符与ascii码转换要耗费时间</li>
</ul>
</li>
<li>按二进制代码存放：<ul>
<li>称为二进制文件</li>
<li>一般用于程序与程序之间、程序与设备之间的数据传递</li>
<li>优：占空间少、无需花费时间来进行二进制与ascii的转换</li>
<li>缺：无法直接输出（是用户看不懂的东西</li>
</ul>
</li>
<li>在文件打开模式中，二进制文件后要加<code>b</code>,如<code>rb和r+b</code>（注意b是写在最后的，如果是rb+，vs报错）</li>
</ul>
<h2 id="C语言文件打开模式"><a href="#C语言文件打开模式" class="headerlink" title="C语言文件打开模式"></a>C语言文件打开模式</h2><table>
<thead>
<tr>
<th style="text-align:center">mode</th>
<th style="text-align:center">处理方式</th>
<th style="text-align:center">文件不存在</th>
<th style="text-align:center">文件存在</th>
<th style="text-align:center">向文件输入</th>
<th style="text-align:center">从文件输出</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">r</td>
<td style="text-align:center">读取</td>
<td style="text-align:center">报错</td>
<td style="text-align:center">打开</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">w</td>
<td style="text-align:center">写入</td>
<td style="text-align:center">新建</td>
<td style="text-align:center">覆盖</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">a</td>
<td style="text-align:center">追加</td>
<td style="text-align:center">新建</td>
<td style="text-align:center">追加</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">r+</td>
<td style="text-align:center">读取/写入</td>
<td style="text-align:center">报错</td>
<td style="text-align:center">打开</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">w+</td>
<td style="text-align:center">读取/写入</td>
<td style="text-align:center">新建</td>
<td style="text-align:center">覆盖</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">a+</td>
<td style="text-align:center">读取/写入</td>
<td style="text-align:center">新建</td>
<td style="text-align:center">追加</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<ol>
<li><p>rwa：读、写、追加；</p>
</li>
<li><p>rwa+：读取/写入、读取/写入、读取/追加（反正都能读</p>
</li>
<li><p>文件存在？</p>
<ul>
<li>文件不存在：报错、新建、新建（rwa+与之同</li>
<li>文件存在：打开、覆盖、追加（rwa+与之同</li>
</ul>
</li>
<li><p>文件输入输出？</p>
<ul>
<li>rwa：读的不能入、写的不能出</li>
<li>rwa+：出入都可以（所以，都加+万无一失）</li>
</ul>
</li>
<li>二进制文件，后面加b即可，如rb</li>
</ol>
<h2 id="b与不-b"><a href="#b与不-b" class="headerlink" title="+b与不+b"></a>+b与不+b</h2><ul>
<li>不加b<ul>
<li>代表是以文本方式打开的文件</li>
<li>常用于fgets  fputs  fprintf fscanf</li>
</ul>
</li>
<li>加b<ul>
<li>代表二进制方式打开的文件</li>
<li>常用于fwrite  fread</li>
</ul>
</li>
<li>实际上区别，就是遇到了\n是不是要转换的问题<ul>
<li>如果是文本方式，写入时遇到’\n’会自动被替换为’\r’’\n’，读取时会将’\r’’\n’替换为’\n’。</li>
<li>如果是二进制方式，不会做任何转换</li>
</ul>
</li>
</ul>
<h2 id="文件基本操作"><a href="#文件基本操作" class="headerlink" title="文件基本操作"></a>文件基本操作</h2><ul>
<li>定义文件指针<ul>
<li><code>FILE * 文件指针名</code></li>
<li><code>FILE * fpFile</code></li>
<li>用指针来操控文件</li>
</ul>
</li>
<li>打开文件，为文件指针赋值<ul>
<li><code>FILE * fopen(char * 文件名, char * 模式)</code>（文件名包括完整路径</li>
<li><code>fpFile = fopen(&quot;C:\\test.txt&quot;, &quot;r&quot;)</code></li>
<li>打开成功返回文件指针，失败返回NULL</li>
</ul>
</li>
<li>关闭文件<ul>
<li><code>fclose(文件指针)</code></li>
<li><code>fclose(fpFile)</code></li>
<li>关闭文件，指针也不再指向它</li>
</ul>
</li>
</ul>
<h2 id="fopen-s安全版文件打开函数"><a href="#fopen-s安全版文件打开函数" class="headerlink" title="fopen_s安全版文件打开函数"></a>fopen_s安全版文件打开函数</h2><ul>
<li><p>fopen同理也有安全版本，fopen_s（不用vs报错），其使用与fopen略有不同</p>
</li>
<li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要定义一个错误变量</span></span><br><span class="line"><span class="keyword">errno_t</span> err;</span><br><span class="line"><span class="comment">//fopen返回值是错误类型（即上述的errno_t类型）</span></span><br><span class="line"><span class="comment">//要赋值给这个错误变量</span></span><br><span class="line">err = fopen_s(&amp;fpFile,filename,<span class="string">"w"</span>)</span><br><span class="line"><span class="comment">//第一个参数是文件指针的地址，文件也是通过此文件变量来控制（同fopen）</span></span><br><span class="line"><span class="comment">//其他两参数同fopen</span></span><br><span class="line"><span class="comment">//打开文件成功返回0，失败返回非0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="文件读写操作"><a href="#文件读写操作" class="headerlink" title="文件读写操作"></a>文件读写操作</h2><ul>
<li><p>总揽</p>
<p>| 操作单位 |  读取   |  写入  |<br>| :——: | :—–: | :—-: |<br>|   字符   |  fgetc  | fputc  |<br>|  字符串  |  fgets  | fputs  |<br>| 格式要求 | fprintf | fscanf |<br>|  数据块  |  fread  | fwrite |</p>
</li>
<li><p><strong>有一个位置指针，不同于文件指针，前者表文件中位置，后者表整个文件</strong>(其实目前我也不确定，当成一个也无伤大雅，自己知道那意思就好)</p>
</li>
</ul>
<h3 id="按字符读写"><a href="#按字符读写" class="headerlink" title="按字符读写"></a>按字符读写</h3><ul>
<li>从文件中，读取一个字符<ul>
<li><code>fget(文件指针)</code>，如<code>fget(fpFile)</code></li>
<li>返回当前位置的字符，位置指针下移1B</li>
</ul>
</li>
<li>向文件中，写入一个字符<ul>
<li><code>fput(字符,文件指针)</code>，如<code>fput(&#39;A&#39;,fpFile)</code></li>
<li>将字符写入当前位置，位置指针下移1B</li>
</ul>
</li>
</ul>
<h3 id="按字符串读写"><a href="#按字符串读写" class="headerlink" title="按字符串读写"></a>按字符串读写</h3><ul>
<li>从文件中，读取一个字符串（暂略</li>
<li>向文件中，写入一个字符串<ul>
<li><code>fputs(字符串，文件指针)</code>，如<code>fputs(&quot;hello&quot;,fpFile)</code></li>
<li>写入成功返回0，失败为EOF</li>
</ul>
</li>
</ul>
<h3 id="按格式要求读写"><a href="#按格式要求读写" class="headerlink" title="按格式要求读写"></a>按格式要求读写</h3><ul>
<li>类比<code>printf scanf</code><ul>
<li>之前输出/入对象是：标准输出/入设备，如今是文件</li>
<li>多了一个文件指针而已</li>
</ul>
</li>
<li>比如<ul>
<li><code>fprintf(fpFile,&quot;%d&quot;,num)</code></li>
<li><code>fscanf(fpFile,&quot;%d&quot;,&amp;num)</code></li>
</ul>
</li>
</ul>
<h3 id="按数据块读写"><a href="#按数据块读写" class="headerlink" title="按数据块读写"></a>按数据块读写</h3><ul>
<li><p>将成批数据块写入文件</p>
<ul>
<li><p><code>fwrite(源起始地址,大小,数据块个数,文件指针)</code>（地址是源地址，即从哪写进文件的）</p>
</li>
<li><p>若成功，返回写入的数据块个数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据结构体类型student，定义相应的结构体变量 数组，stu[20]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>[20];</span></span><br><span class="line"></span><br><span class="line">fwrite(&amp;stu[<span class="number">0</span>], <span class="keyword">sizeof</span>(struct student), <span class="number">2</span>, fpFile);</span><br><span class="line"><span class="comment">//从stu[0]的地址开始写入（对文件来说，即源地址</span></span><br><span class="line"><span class="comment">//将结构体类型student（所占的空间）作为一个数据块</span></span><br><span class="line"><span class="comment">//向fpFile所指向的文件</span></span><br><span class="line"><span class="comment">//写入两个数据块，即stu[0]，stu[1]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>从文件中读取将成批数据块</p>
<ul>
<li><code>fwrite(目的起始地址,大小,数据块个数,文件指针)</code>（地址是目的地址，即读出来之后放在哪</li>
</ul>
</li>
<li>数据块的这俩函数常用于二进制文件的读写中</li>
</ul>
<h2 id="二进制文件读写"><a href="#二进制文件读写" class="headerlink" title="二进制文件读写"></a>二进制文件读写</h2><ul>
<li><p>写入文件，fwrite函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Book books_input[<span class="number">2</span>] = &#123; &#123; <span class="string">"书名1"</span>, <span class="string">"作者1"</span>, <span class="number">99.8</span> &#125;,&#123; <span class="string">"书名2"</span>, <span class="string">"作者2"</span>, <span class="number">88.8</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">int</span> arry_input[<span class="number">10</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">FILE* fpFile;</span><br><span class="line"><span class="keyword">errno_t</span> err;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从本程序中的数组，写入到文件</span></span><br><span class="line">err = fopen_s(&amp;fpFile, <span class="string">"./test.txt"</span>, <span class="string">"wb"</span>);</span><br><span class="line"><span class="keyword">if</span> (!err)</span><br><span class="line">&#123;</span><br><span class="line">  fwrite(books_input, <span class="keyword">sizeof</span>(Book), _countof(books_input), fpFile);</span><br><span class="line">  fwrite(arry_input, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), _countof(arry_input), fpFile);</span><br><span class="line">  fclose(fpFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>读取文件，fread函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Book books_output[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> arry_output[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">FILE* fpFile;</span><br><span class="line"><span class="keyword">errno_t</span> err;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将文件中的数据，写入本程序中的数组</span></span><br><span class="line">err = fopen_s(&amp;fpFile, <span class="string">"./test.txt"</span>, <span class="string">"rb"</span>);</span><br><span class="line"><span class="keyword">if</span> (!err)</span><br><span class="line">&#123;</span><br><span class="line">  fread(books_output, <span class="keyword">sizeof</span>(Book), _countof(books_input), fpFile);</span><br><span class="line">  fread(arry_output, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), _countof(arry_input), fpFile);</span><br><span class="line">  fclose(fpFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="其他文件操作函数"><a href="#其他文件操作函数" class="headerlink" title="其他文件操作函数"></a>其他文件操作函数</h2><ul>
<li><code>feof(文件指针)</code><ul>
<li>检测位置指针，是否指到了文件的最后（文件最后的结束标志是<code>EOF</code>，字符串最后是<code>\0</code>）   </li>
<li>若指向了最后（即当前位置是EOF），则返回非零值，否则返回0</li>
</ul>
</li>
<li><code>rewind(文件指针)</code>（注意这个没有f前缀<ul>
<li>将位置指针，重新指向文件开始位置</li>
<li>无返回值</li>
</ul>
</li>
<li><code>fseek(文件指针,偏移量,起始位置)</code><ul>
<li>控制指针，指向文件中任何一位置，实现随机读写</li>
<li>起始位置，用宏表示<ul>
<li><code>SEEK_SET</code>：文件开始位置</li>
<li><code>SEEK_CUR</code>：位置指针指向的当前位置</li>
<li><code>SEEK_END</code>：文件结束位置</li>
</ul>
</li>
<li>偏移量，长整型数，正数后移，负数左移</li>
<li>若指针设置成功，返回0，否则返回非0（同feod相反，那到了最后返回非零，这设置成功返回0</li>
</ul>
</li>
<li><code>ftell(文件指针)</code><ul>
<li>测试当前指针指向的位置在哪？<ul>
<li>测试成功，则返回当前位置距离文件开始位置的字节数</li>
<li>失败则返回<code>-1L</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="r-与w-与a"><a href="#r-与w-与a" class="headerlink" title="r+与w+与a+"></a>r+与w+与a+</h2><ul>
<li><code>r+</code>：<pre><code>打开时，文件内部读写位置指针指向文件头
</code></pre><ul>
<li>可以通过文件随机定位函数 fseek()来把文件内部读写位置指针移到指定位置修改文件内容</li>
</ul>
</li>
<li><code>a+</code>：<ul>
<li>打开时文件内部读写位置指针指向文件尾</li>
<li>可以通过文件随机定位函数 fseek()来把文件内部读写位置指针移到指定位置修改文件内容</li>
</ul>
</li>
<li><code>w+</code>：<ul>
<li>打开时，若文件已存在，则会破坏文件内原有的所有内容</li>
<li>因此不适合用来修改已有文件内容</li>
</ul>
</li>
<li><code>r+ w+ a+</code>区别<ul>
<li>r+ 和 w+ <ul>
<li>r+ ：可直接写在文件上，读取和写入的光标都在文件开头</li>
<li>w+ ：若文件已经存在，将新建文件覆盖原文件</li>
</ul>
</li>
<li>a+ 和 r+<ul>
<li>a+：只能在文件最后补充，光标在结尾</li>
<li>r+：可以覆盖前面的内容，光标在开头</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="其他-3"><a href="#其他-3" class="headerlink" title="其他"></a>其他</h2><ul>
<li><p>这么来看，对于任意修改文件内容，r+最好（光标在开头，可以任意修改已有内容和添加新内容）</p>
<ul>
<li>w+：会覆盖新文件</li>
<li>a+：只能追加，前面的内容管不到</li>
</ul>
</li>
<li><p>fopen打开文件时，要注意mode这个参数要用双引号，而非单引号（单引号会当作普通字符处理，有一种说法是双引号中的才会解析，即起作用）</p>
</li>
<li><p><code>fscanf</code>也有安全版本<code>fscanf_s</code>，与scanf同理，都在最后多一个限制长度的参数</p>
</li>
<li><p>打开文件时文件名</p>
<ul>
<li>包括完整的文件路径</li>
<li>可以是绝对路径，也可以是相对路径</li>
<li>可以用<code>/</code>也可用<code>\</code>，但是<code>\</code>要用两个（因为有转义的作用</li>
</ul>
</li>
<li><p>结构体的重命名问题（自己想的，未求证</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">BOOK</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;BOOK, *PBOOK</span><br><span class="line"><span class="comment">//将结构体struct _BOOK重新命名为BOOK（因为C中要用struct，而C++不用，这样来统一</span></span><br><span class="line"><span class="comment">//将结构体struct _BOOK的指针，重新命名为 PBOOK</span></span><br><span class="line"><span class="comment">//这样就不用struct _BOOK * p了，直接PBOOK * p即可</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>VS中正则表达式匹配空行<code>^(\s*)\n</code>（^表开头，\s表任何空白字符，*表多个，\n表换行（\n不行就\r）</p>
</li>
<li><p>为何用fwrite、以二进制形式，向文件中写入字符产和数字，记事本打开数字会乱码、字符串正常（正常现象，与计算机的编码解码有关，不必深究，其他写入函数可能也会如此）</p>
</li>
<li></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C-C/" rel="tag"># C/C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/05/C:C++基础-01/" rel="next" title="C/C++基础_01">
                <i class="fa fa-chevron-left"></i> C/C++基础_01
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/07/22/C:C++基础-03/" rel="prev" title="C/C++基础-03">
                C/C++基础-03 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Ry1ynn">
            
              <p class="site-author-name" itemprop="name">Ry1ynn</p>
              <p class="site-description motion-element" itemprop="description">好好学习 天天向上</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">133</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">57</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Ry1ynn" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:ry1ynn_pri@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="/images/weixin.JPG" target="_blank" title="Wechat">
                      
                        <i class="fa fa-fw fa-weixin"></i>Wechat</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.t00ls.net/" title="T00ls" target="_blank">T00ls</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.freebuf.com/" title="FreeBuf" target="_blank">FreeBuf</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.sec-wiki.com/" title="SecWiki" target="_blank">SecWiki</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.seebug.org/" title="Seebug" target="_blank">Seebug</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.91ri.org/" title="91Ri" target="_blank">91Ri</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.pediy.com/" title="看雪" target="_blank">看雪</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.52pojie.cn/" title="吾爱破解" target="_blank">吾爱破解</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.anquanke.com/" title="安全客" target="_blank">安全客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.ichunqiu.com/" title="i春秋" target="_blank">i春秋</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#16-宏"><span class="nav-text">16-宏</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#有参宏"><span class="nav-text">有参宏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#两种include"><span class="nav-text">两种include</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#17-函数"><span class="nav-text">17-函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概念"><span class="nav-text">概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#形参与实参"><span class="nav-text">形参与实参</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#素（质）数判别"><span class="nav-text">素（质）数判别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18-变量类型"><span class="nav-text">18-变量类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#特殊变量特点"><span class="nav-text">特殊变量特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const"><span class="nav-text">const</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static"><span class="nav-text">static</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全局-VS-局部变量"><span class="nav-text">全局 VS 局部变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态、局部、全局变量比较"><span class="nav-text">静态、局部、全局变量比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全局变量-amp-extern、static"><span class="nav-text">全局变量 &amp; extern、static</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19-指针基础"><span class="nav-text">19-指针基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#指针、-、-amp"><span class="nav-text">指针、*、&amp;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针指向其他类型变量？"><span class="nav-text">指针指向其他类型变量？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三个数字排序"><span class="nav-text">三个数字排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#20-VS相关"><span class="nav-text">20-VS相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#sizeof获取数组长度问题："><span class="nav-text">sizeof获取数组长度问题：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见的两层循环思想："><span class="nav-text">常见的两层循环思想：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VS-单步调试"><span class="nav-text">VS 单步调试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#21-结构体-联合体-typedef"><span class="nav-text">21-结构体-联合体-typedef</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#如何处理各种数据"><span class="nav-text">如何处理各种数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结构体定义的三种形式"><span class="nav-text">结构体定义的三种形式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定义结构体变量时struct写不写？"><span class="nav-text">定义结构体变量时struct写不写？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结构体与联合体"><span class="nav-text">结构体与联合体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结构体变量的赋值"><span class="nav-text">结构体变量的赋值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他"><span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#22-堆空间与内存操作函数"><span class="nav-text">22-堆空间与内存操作函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#内存操作函数"><span class="nav-text">内存操作函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#溢出与泄漏"><span class="nav-text">溢出与泄漏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆与数组"><span class="nav-text">堆与数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆与栈"><span class="nav-text">堆与栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#悬空指针与野指针"><span class="nav-text">悬空指针与野指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用原则、注意事项"><span class="nav-text">使用原则、注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他-1"><span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#23-运行期内存、变量生存期"><span class="nav-text">23-运行期内存、变量生存期</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#运行期内存"><span class="nav-text">运行期内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不同类型变量的生存期与作用域"><span class="nav-text">不同类型变量的生存期与作用域</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#24-指针进阶"><span class="nav-text">24-指针进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#strlen-、sizeof-、-countof"><span class="nav-text">strlen()、sizeof()、_countof()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组退化为指针"><span class="nav-text">数组退化为指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针形式字符串与数组形式字符串"><span class="nav-text">指针形式字符串与数组形式字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数指针"><span class="nav-text">函数指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针占了多少空间？"><span class="nav-text">指针占了多少空间？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#野指针、悬空指针"><span class="nav-text">野指针、悬空指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组传参"><span class="nav-text">数组传参</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针与一维数组"><span class="nav-text">指针与一维数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针与二维数组"><span class="nav-text">指针与二维数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针与二维数组画图理解"><span class="nav-text">指针与二维数组画图理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组指针与指针数组"><span class="nav-text">数组指针与指针数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针分级"><span class="nav-text">指针分级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他-2"><span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#25-文件操作"><span class="nav-text">25-文件操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C中文件分类"><span class="nav-text">C中文件分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C语言文件打开模式"><span class="nav-text">C语言文件打开模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#b与不-b"><span class="nav-text">+b与不+b</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件基本操作"><span class="nav-text">文件基本操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fopen-s安全版文件打开函数"><span class="nav-text">fopen_s安全版文件打开函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件读写操作"><span class="nav-text">文件读写操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#按字符读写"><span class="nav-text">按字符读写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#按字符串读写"><span class="nav-text">按字符串读写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#按格式要求读写"><span class="nav-text">按格式要求读写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#按数据块读写"><span class="nav-text">按数据块读写</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二进制文件读写"><span class="nav-text">二进制文件读写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他文件操作函数"><span class="nav-text">其他文件操作函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#r-与w-与a"><span class="nav-text">r+与w+与a+</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他-3"><span class="nav-text">其他</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ry1ynn</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  










  



  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script id="ribbon" type="text/javascript" size="300" alpha="0.5" zindex="0" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
