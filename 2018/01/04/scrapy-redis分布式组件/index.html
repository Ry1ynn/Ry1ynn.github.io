<!DOCTYPE html>



  



<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">






  <meta name="keywords" content="python,爬虫,">










<meta name="description" content="scrapy-shell分布式组件00-简介 Scrapy 是一个通用的爬虫框架，但是不支持分布式，Scrapy-redis是为了更方便地实现Scrapy分布式爬取，而提供了一些以redis为基础的组件(仅有组件)  pip install scrapy-redis  Scrapy-redis提供了下面四种组件（components）：(四种组件意味着这四个模块都要做相应的修改)  Schedul">
<meta name="keywords" content="python,爬虫">
<meta property="og:type" content="article">
<meta property="og:title" content="scrapy_redis分布式组件">
<meta property="og:url" content="http://21guns.top/2018/01/04/scrapy-redis分布式组件/index.html">
<meta property="og:site_name" content="Ry1ynn&#39;s blogs">
<meta property="og:description" content="scrapy-shell分布式组件00-简介 Scrapy 是一个通用的爬虫框架，但是不支持分布式，Scrapy-redis是为了更方便地实现Scrapy分布式爬取，而提供了一些以redis为基础的组件(仅有组件)  pip install scrapy-redis  Scrapy-redis提供了下面四种组件（components）：(四种组件意味着这四个模块都要做相应的修改)  Schedul">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://ot12pfxkm.bkt.clouddn.com/18-1-5/68915657.jpg?ynotemdtimestamp=1550480738159">
<meta property="og:updated_time" content="2019-02-18T09:14:07.492Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="scrapy_redis分布式组件">
<meta name="twitter:description" content="scrapy-shell分布式组件00-简介 Scrapy 是一个通用的爬虫框架，但是不支持分布式，Scrapy-redis是为了更方便地实现Scrapy分布式爬取，而提供了一些以redis为基础的组件(仅有组件)  pip install scrapy-redis  Scrapy-redis提供了下面四种组件（components）：(四种组件意味着这四个模块都要做相应的修改)  Schedul">
<meta name="twitter:image" content="http://ot12pfxkm.bkt.clouddn.com/18-1-5/68915657.jpg?ynotemdtimestamp=1550480738159">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://21guns.top/2018/01/04/scrapy-redis分布式组件/">





  <title>scrapy_redis分布式组件 | Ry1ynn's blogs</title>
  










</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ry1ynn's blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://21guns.top/2018/01/04/scrapy-redis分布式组件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ry1ynn">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ry1ynn's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">scrapy_redis分布式组件</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-04T17:06:11+08:00">
                2018-01-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/爬虫/" itemprop="url" rel="index">
                    <span itemprop="name">爬虫</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="scrapy-shell分布式组件"><a href="#scrapy-shell分布式组件" class="headerlink" title="scrapy-shell分布式组件"></a>scrapy-shell分布式组件</h1><h2 id="00-简介"><a href="#00-简介" class="headerlink" title="00-简介"></a>00-简介</h2><ul>
<li><p>Scrapy 是一个通用的爬虫框架，但是不支持分布式，Scrapy-redis是为了更方便地实现Scrapy分布式爬取，而提供了一些以redis为基础的组件(仅有组件)</p>
</li>
<li><p>pip install scrapy-redis</p>
</li>
<li><p>Scrapy-redis提供了下面四种组件（components）：(四种组件意味着这四个模块都要做相应的修改)</p>
<ul>
<li><code>Scheduler</code></li>
<li><code>Duplication Filter</code></li>
<li><code>Item Pipeline</code><a id="more"></a></li>
<li><code>Base Spider</code></li>
</ul>
</li>
<li><p>scrapy-redis架构</p>
<p><img src="http://ot12pfxkm.bkt.clouddn.com/18-1-5/68915657.jpg?ynotemdtimestamp=1550480738159" alt="img"></p>
</li>
<li><p>如上图所⽰示，scrapy-redis在scrapy的架构上增加了redis，基于redis的特性拓展了如下组件</p>
</li>
<li><p>Scheduler：</p>
<ul>
<li><p>Scrapy改造了python本来的collection.deque(双向队列)形成了自己的Scrapy queue(<a href="https://github.com/scrapy/queuelib/blob/master/queuelib/queue.py" target="_blank" rel="noopener">https://github.com/scrapy/queuelib/blob/master/queuelib/queue.py)</a>)，但是Scrapy多个spider不能共享待爬取队列Scrapy queue， 即Scrapy本身不支持爬虫分布式，scrapy-redis 的解决是把这个Scrapy queue换成redis数据库（也是指redis队列），从同一个redis-server存放要爬取的request，便能让多个spider去同一个数据库里读取。</p>
</li>
<li><p>Scrapy中跟“待爬队列”直接相关的就是调度器<code>Scheduler</code>，它负责对新的request进行入列操作（加入Scrapy queue），取出下一个要爬取的request（从Scrapy queue中取出）等操作。它把待爬队列按照优先级建立了一个字典结构，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    优先级0 : 队列0</span><br><span class="line">    优先级1 : 队列1</span><br><span class="line">    优先级2 : 队列2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后根据request中的优先级，来决定该入哪个队列，出列时则按优先级较小的优先出列。为了管理这个比较高级的队列字典，Scheduler需要提供一系列的方法。但是原来的Scheduler已经无法使用，所以使用Scrapy-redis的scheduler组件。</p>
</li>
</ul>
</li>
<li><p>Duplication Filter</p>
<ul>
<li><p>Scrapy中用集合实现这个request去重功能，Scrapy中把已经发送的request指纹放入到一个集合中，把下一个request的指纹拿到集合中比对，如果该指纹存在于集合中，说明这个request发送过了，如果没有则继续操作。</p>
</li>
<li><p>核心的判重功能是这样实现的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def request_seen(self, request):</span><br><span class="line">    # self.request_figerprints就是一个指纹集合  </span><br><span class="line">    fp = self.request_fingerprint(request)</span><br><span class="line"></span><br><span class="line">    # 这就是判重的核心操作  </span><br><span class="line">    if fp in self.fingerprints:</span><br><span class="line">        return True</span><br><span class="line">    self.fingerprints.add(fp)</span><br><span class="line">    if self.file:</span><br><span class="line">        self.file.write(fp + os.linesep)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在scrapy-redis中去重是由<code>Duplication Filter</code>组件来实现的，它通过redis的set 不重复的特性，巧妙的实现了Duplication Filter去重。scrapy-redis调度器从引擎接受request，将request的指纹存⼊redis的set检查是否重复，并将不重复的request push写⼊redis的 request queue。</p>
</li>
<li><p>引擎请求request(Spider发出的）时，调度器从redis的request queue队列⾥里根据优先级pop 出⼀个request 返回给引擎，引擎将此request发给spider处理。</p>
</li>
</ul>
</li>
<li><p>Item Pipeline：</p>
<ul>
<li>引擎将(Spider返回的)爬取到的Item给Item Pipeline，scrapy-redis 的Item Pipeline将爬取到的 Item 存⼊redis的 items queue。</li>
<li>修改过<code>Item Pipeline</code>可以很方便的根据 key 从 items queue 提取item，从⽽实现 <code>items processes</code>集群。</li>
</ul>
</li>
<li><p>Base Spider</p>
<ul>
<li>不在使用scrapy原有的Spider类，重写的<code>RedisSpider</code>继承了Spider和RedisMixin这两个类，RedisMixin是用来从redis读取url的类。</li>
<li>当我们生成一个Spider继承RedisSpider时，调用setup_redis函数，这个函数会去连接redis数据库，然后会设置signals(信号)：<ul>
<li>一个是当spider空闲时候的signal，会调用spider_idle函数，这个函数调用<code>schedule_next_request</code>函数，保证spider是一直活着的状态，并且抛出DontCloseSpider异常。</li>
<li>一个是当抓到一个item时的signal，会调用item_scraped函数，这个函数会调用<code>schedule_next_request</code>函数，获取下一个request。</li>
</ul>
</li>
</ul>
</li>
<li><p>crapy-redis的官方文档写的比较简洁，没有提及其运行原理，所以如果想全面的理解分布式爬虫的运行原理，还是得看scrapy-redis的源代码才行。</p>
</li>
<li><p>scrapy-redis工程的主体还是是redis和scrapy两个库，工程本身实现的东西不是很多，这个工程就像胶水一样，把这两个插件粘结了起来。下面我们来看看，scrapy-redis的每一个源代码文件都实现了什么功能，最后如何实现分布式的爬虫系统：</p>
</li>
</ul>
<h2 id="01-源码解读：Connection"><a href="#01-源码解读：Connection" class="headerlink" title="01-源码解读：Connection"></a>01-源码解读：Connection</h2><ul>
<li><p><a href="https://github.com/rolando/scrapy-redis/blob/master/src/scrapy_redis/connection.py" target="_blank" rel="noopener">connection.py</a></p>
<p>负责根据setting中配置实例化redis连接。被dupefilter和scheduler调用，总之涉及到redis存取的都要使用到这个模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"># 这里引入了redis模块，这个是redis-python库的接口，用于通过python访问redis数据库，</span><br><span class="line"># 这个文件主要是实现连接redis数据库的功能，这些连接接口在其他文件中经常被用到</span><br><span class="line"></span><br><span class="line">import redis</span><br><span class="line">import six</span><br><span class="line"></span><br><span class="line">from scrapy.utils.misc import load_object</span><br><span class="line"></span><br><span class="line">DEFAULT_REDIS_CLS = redis.StrictRedis</span><br><span class="line"></span><br><span class="line"># 可以在settings文件中配置套接字的超时时间、等待时间等</span><br><span class="line"># Sane connection defaults.</span><br><span class="line">DEFAULT_PARAMS = &#123;</span><br><span class="line">    &apos;socket_timeout&apos;: 30,</span><br><span class="line">    &apos;socket_connect_timeout&apos;: 30,</span><br><span class="line">    &apos;retry_on_timeout&apos;: True,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 要想连接到redis数据库，和其他数据库差不多，需要一个ip地址、端口号、用户名密码（可选）和一个整形的数据库编号</span><br><span class="line"># Shortcut maps &apos;setting name&apos; -&gt; &apos;parmater name&apos;.</span><br><span class="line">SETTINGS_PARAMS_MAP = &#123;</span><br><span class="line">    &apos;REDIS_URL&apos;: &apos;url&apos;,</span><br><span class="line">    &apos;REDIS_HOST&apos;: &apos;host&apos;,</span><br><span class="line">    &apos;REDIS_PORT&apos;: &apos;port&apos;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_redis_from_settings(settings):</span><br><span class="line">    &quot;&quot;&quot;Returns a redis client instance from given Scrapy settings object.</span><br><span class="line">    This function uses ``get_client`` to instantiate the client and uses</span><br><span class="line">    ``DEFAULT_PARAMS`` global as defaults values for the parameters. You can</span><br><span class="line">    override them using the ``REDIS_PARAMS`` setting.</span><br><span class="line">    Parameters</span><br><span class="line">    ----------</span><br><span class="line">    settings : Settings</span><br><span class="line">        A scrapy settings object. See the supported settings below.</span><br><span class="line">    Returns</span><br><span class="line">    -------</span><br><span class="line">    server</span><br><span class="line">        Redis client instance.</span><br><span class="line">    Other Parameters</span><br><span class="line">    ----------------</span><br><span class="line">    REDIS_URL : str, optional</span><br><span class="line">        Server connection URL.</span><br><span class="line">    REDIS_HOST : str, optional</span><br><span class="line">        Server host.</span><br><span class="line">    REDIS_PORT : str, optional</span><br><span class="line">        Server port.</span><br><span class="line">    REDIS_PARAMS : dict, optional</span><br><span class="line">        Additional client parameters.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    params = DEFAULT_PARAMS.copy()</span><br><span class="line">    params.update(settings.getdict(&apos;REDIS_PARAMS&apos;))</span><br><span class="line">    # XXX: Deprecate REDIS_* settings.</span><br><span class="line">    for source, dest in SETTINGS_PARAMS_MAP.items():</span><br><span class="line">        val = settings.get(source)</span><br><span class="line">        if val:</span><br><span class="line">            params[dest] = val</span><br><span class="line"></span><br><span class="line">    # Allow ``redis_cls`` to be a path to a class.</span><br><span class="line">    if isinstance(params.get(&apos;redis_cls&apos;), six.string_types):</span><br><span class="line">        params[&apos;redis_cls&apos;] = load_object(params[&apos;redis_cls&apos;])</span><br><span class="line"></span><br><span class="line">    # 返回的是redis库的Redis对象，可以直接用来进行数据操作的对象</span><br><span class="line">    return get_redis(**params)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Backwards compatible alias.</span><br><span class="line">from_settings = get_redis_from_settings</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_redis(**kwargs):</span><br><span class="line">    &quot;&quot;&quot;Returns a redis client instance.</span><br><span class="line">    Parameters</span><br><span class="line">    ----------</span><br><span class="line">    redis_cls : class, optional</span><br><span class="line">        Defaults to ``redis.StrictRedis``.</span><br><span class="line">    url : str, optional</span><br><span class="line">        If given, ``redis_cls.from_url`` is used to instantiate the class.</span><br><span class="line">    **kwargs</span><br><span class="line">        Extra parameters to be passed to the ``redis_cls`` class.</span><br><span class="line">    Returns</span><br><span class="line">    -------</span><br><span class="line">    server</span><br><span class="line">        Redis client instance.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    redis_cls = kwargs.pop(&apos;redis_cls&apos;, DEFAULT_REDIS_CLS)</span><br><span class="line">    url = kwargs.pop(&apos;url&apos;, None)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if url:</span><br><span class="line">        return redis_cls.from_url(url, **kwargs)</span><br><span class="line">    else:</span><br><span class="line">        return redis_cls(**kwargs)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="02-源码解读：Dupefilter"><a href="#02-源码解读：Dupefilter" class="headerlink" title="02-源码解读：Dupefilter"></a>02-源码解读：Dupefilter</h2><ul>
<li><p>负责执行requst的去重，实现的很有技巧性，使用redis的set数据结构。但是注意scheduler并不使用其中用于在这个模块中实现的dupefilter键做request的调度，而是使用queue.py模块中实现的queue。</p>
</li>
<li><p>当request不重复时，将其存入到queue中，调度时将其弹出。</p>
</li>
<li><p>code：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">from scrapy.dupefilters import BaseDupeFilter</span><br><span class="line">from scrapy.utils.request import request_fingerprint</span><br><span class="line"></span><br><span class="line">from .connection import get_redis_from_settings</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DEFAULT_DUPEFILTER_KEY = &quot;dupefilter:%(timestamp)s&quot;</span><br><span class="line"></span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># TODO: Rename class to RedisDupeFilter.</span><br><span class="line">class RFPDupeFilter(BaseDupeFilter):</span><br><span class="line">    &quot;&quot;&quot;Redis-based request duplicates filter.</span><br><span class="line">    This class can also be used with default Scrapy&apos;s scheduler.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    logger = logger</span><br><span class="line"></span><br><span class="line">    def __init__(self, server, key, debug=False):</span><br><span class="line">        &quot;&quot;&quot;Initialize the duplicates filter.</span><br><span class="line">        Parameters</span><br><span class="line">        ----------</span><br><span class="line">        server : redis.StrictRedis</span><br><span class="line">            The redis server instance.</span><br><span class="line">        key : str</span><br><span class="line">            Redis key Where to store fingerprints.</span><br><span class="line">        debug : bool, optional</span><br><span class="line">            Whether to log filtered requests.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.server = server</span><br><span class="line">        self.key = key</span><br><span class="line">        self.debug = debug</span><br><span class="line">        self.logdupes = True</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def from_settings(cls, settings):</span><br><span class="line">        &quot;&quot;&quot;Returns an instance from given settings.</span><br><span class="line">        This uses by default the key ``dupefilter:&lt;timestamp&gt;``. When using the</span><br><span class="line">        ``scrapy_redis.scheduler.Scheduler`` class, this method is not used as</span><br><span class="line">        it needs to pass the spider name in the key.</span><br><span class="line">        Parameters</span><br><span class="line">        ----------</span><br><span class="line">        settings : scrapy.settings.Settings</span><br><span class="line">        Returns</span><br><span class="line">        -------</span><br><span class="line">        RFPDupeFilter</span><br><span class="line">            A RFPDupeFilter instance.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        server = get_redis_from_settings(settings)</span><br><span class="line">        # XXX: This creates one-time key. needed to support to use this</span><br><span class="line">        # class as standalone dupefilter with scrapy&apos;s default scheduler</span><br><span class="line">        # if scrapy passes spider on open() method this wouldn&apos;t be needed</span><br><span class="line">        # TODO: Use SCRAPY_JOB env as default and fallback to timestamp.</span><br><span class="line">        key = DEFAULT_DUPEFILTER_KEY % &#123;&apos;timestamp&apos;: int(time.time())&#125;</span><br><span class="line">        debug = settings.getbool(&apos;DUPEFILTER_DEBUG&apos;)</span><br><span class="line">        return cls(server, key=key, debug=debug)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def from_crawler(cls, crawler):</span><br><span class="line">        &quot;&quot;&quot;Returns instance from crawler.</span><br><span class="line">        Parameters</span><br><span class="line">        ----------</span><br><span class="line">        crawler : scrapy.crawler.Crawler</span><br><span class="line">        Returns</span><br><span class="line">        -------</span><br><span class="line">        RFPDupeFilter</span><br><span class="line">            Instance of RFPDupeFilter.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return cls.from_settings(crawler.settings)</span><br><span class="line"></span><br><span class="line">    def request_seen(self, request):</span><br><span class="line">        &quot;&quot;&quot;Returns True if request was already seen.</span><br><span class="line">        Parameters</span><br><span class="line">        ----------</span><br><span class="line">        request : scrapy.http.Request</span><br><span class="line">        Returns</span><br><span class="line">        -------</span><br><span class="line">        bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        fp = self.request_fingerprint(request)</span><br><span class="line">        # This returns the number of values added, zero if already exists.</span><br><span class="line">        added = self.server.sadd(self.key, fp)</span><br><span class="line">        return added == 0</span><br><span class="line"></span><br><span class="line">    def request_fingerprint(self, request):</span><br><span class="line">        &quot;&quot;&quot;Returns a fingerprint for a given request.</span><br><span class="line">        Parameters</span><br><span class="line">        ----------</span><br><span class="line">        request : scrapy.http.Request</span><br><span class="line">        Returns</span><br><span class="line">        -------</span><br><span class="line">        str</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return request_fingerprint(request)</span><br><span class="line"></span><br><span class="line">    def close(self, reason=&apos;&apos;):</span><br><span class="line">        &quot;&quot;&quot;Delete data on close. Called by Scrapy&apos;s scheduler.</span><br><span class="line">        Parameters</span><br><span class="line">        ----------</span><br><span class="line">        reason : str, optional</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.clear()</span><br><span class="line"></span><br><span class="line">    def clear(self):</span><br><span class="line">        &quot;&quot;&quot;Clears fingerprints data.&quot;&quot;&quot;</span><br><span class="line">        self.server.delete(self.key)</span><br><span class="line"></span><br><span class="line">    def log(self, request, spider):</span><br><span class="line">        &quot;&quot;&quot;Logs given request.</span><br><span class="line">        Parameters</span><br><span class="line">        ----------</span><br><span class="line">        request : scrapy.http.Request</span><br><span class="line">        spider : scrapy.spiders.Spider</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if self.debug:</span><br><span class="line">            msg = &quot;Filtered duplicate request: %(request)s&quot;</span><br><span class="line">            self.logger.debug(msg, &#123;&apos;request&apos;: request&#125;, extra=&#123;&apos;spider&apos;: spider&#125;)</span><br><span class="line">        elif self.logdupes:</span><br><span class="line">            msg = (&quot;Filtered duplicate request %(request)s&quot;</span><br><span class="line">                   &quot; - no more duplicates will be shown&quot;</span><br><span class="line">                   &quot; (see DUPEFILTER_DEBUG to show all duplicates)&quot;)</span><br><span class="line">            msg = &quot;Filtered duplicate request: %(request)s&quot;</span><br><span class="line">            self.logger.debug(msg, &#123;&apos;request&apos;: request&#125;, extra=&#123;&apos;spider&apos;: spider&#125;)</span><br><span class="line">            self.logdupes = False</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个文件看起来比较复杂，重写了scrapy本身已经实现的request判重功能。因为本身scrapy单机跑的话，只需要读取内存中的request队列或者持久化的request队列（scrapy默认的持久化似乎是json格式的文件，不是数据库）就能判断这次要发出的request url是否已经请求过或者正在调度（本地读就行了）。而分布式跑的话，就需要各个主机上的scheduler都连接同一个数据库的同一个request池来判断这次的请求是否是重复的了。</p>
</li>
<li><p>在这个文件中，通过继承BaseDupeFilter重写他的方法，实现了基于redis的判重。根据源代码来看，scrapy-redis使用了scrapy本身的一个fingerprint接request_fingerprint，这个接口很有趣，根据scrapy文档所说，他通过hash来判断两个url是否相同（相同的url会生成相同的hash结果），但是当两个url的地址相同，get型参数相同但是顺序不同时，也会生成相同的hash结果（这个真的比较神奇。。。）所以scrapy-redis依旧使用url的fingerprint来判断request请求是否已经出现过。</p>
</li>
<li><p>这个类通过连接redis，使用一个key来向redis的一个set中插入fingerprint（这个key对于同一种spider是相同的，redis是一个key-value的数据库，如果key是相同的。访问到的值就是相同的，这里使用spider名字+DupeFilter的key就是为了在不同主机上的不同爬虫实例，只要属于同一种spider，就会访问到同一个set，而这个set就是他们的url判重池），如果返回值为0，说明该set中该fingerprint已经存在（因为集合是没有重复值的），则返回False，如果返回值为1，说明添加了一个fingerprint到set中，则说明这个request没有重复，于是返回True，还顺便把新fingerprint加入到数据库中了。 DupeFilter判重会在scheduler类中用到，每一个request在进入调度之前都要进行判重，如果重复就不需要参加调度，直接舍弃就好了，不然就是白白浪费资源。</p>
</li>
</ul>
<h2 id="03-源码解读：Picklecompat"><a href="#03-源码解读：Picklecompat" class="headerlink" title="03-源码解读：Picklecompat"></a>03-源码解读：Picklecompat</h2><ul>
<li><p>code</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;A pickle wrapper module with protocol=-1 by default.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    import cPickle as pickle  # PY2</span><br><span class="line">except ImportError:</span><br><span class="line">    import pickle</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def loads(s):</span><br><span class="line">    return pickle.loads(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dumps(obj):</span><br><span class="line">    return pickle.dumps(obj, protocol=-1)</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里实现了loads和dumps两个函数，其实就是实现了一个序列化器。</p>
</li>
<li><p>因为redis数据库不能存储复杂对象（key部分只能是字符串，value部分只能是字符串，字符串列表，字符串集合和hash），所以我们存啥都要先串行化成文本才行。</p>
</li>
<li><p>这里使用的就是python的pickle模块，一个兼容py2和py3的串行化工具。这个serializer主要用于一会的scheduler存reuqest对象。</p>
</li>
</ul>
<h2 id="04-源码解读：Pipelines"><a href="#04-源码解读：Pipelines" class="headerlink" title="04-源码解读：Pipelines"></a>04-源码解读：Pipelines</h2><ul>
<li><p>这是是用来实现分布式处理的作用。它将Item存储在redis中以实现分布式处理。由于在这里需要读取配置，所以就用到了from_crawler()函数。</p>
</li>
<li><p>code</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">from scrapy.utils.misc import load_object</span><br><span class="line">from scrapy.utils.serialize import ScrapyJSONEncoder</span><br><span class="line">from twisted.internet.threads import deferToThread</span><br><span class="line"></span><br><span class="line">from . import connection</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">default_serialize = ScrapyJSONEncoder().encode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class RedisPipeline(object):</span><br><span class="line">    &quot;&quot;&quot;Pushes serialized item into a redis list/queue&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, server,</span><br><span class="line">                 key=&apos;%(spider)s:items&apos;,</span><br><span class="line">                 serialize_func=default_serialize):</span><br><span class="line">        self.server = server</span><br><span class="line">        self.key = key</span><br><span class="line">        self.serialize = serialize_func</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def from_settings(cls, settings):</span><br><span class="line">        params = &#123;</span><br><span class="line">            &apos;server&apos;: connection.from_settings(settings),</span><br><span class="line">        &#125;</span><br><span class="line">        if settings.get(&apos;REDIS_ITEMS_KEY&apos;):</span><br><span class="line">            params[&apos;key&apos;] = settings[&apos;REDIS_ITEMS_KEY&apos;]</span><br><span class="line">        if settings.get(&apos;REDIS_ITEMS_SERIALIZER&apos;):</span><br><span class="line">            params[&apos;serialize_func&apos;] = load_object(</span><br><span class="line">                settings[&apos;REDIS_ITEMS_SERIALIZER&apos;]</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        return cls(**params)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def from_crawler(cls, crawler):</span><br><span class="line">        return cls.from_settings(crawler.settings)</span><br><span class="line"></span><br><span class="line">    def process_item(self, item, spider):</span><br><span class="line">        return deferToThread(self._process_item, item, spider)</span><br><span class="line"></span><br><span class="line">    def _process_item(self, item, spider):</span><br><span class="line">        key = self.item_key(item, spider)</span><br><span class="line">        data = self.serialize(item)</span><br><span class="line">        self.server.rpush(key, data)</span><br><span class="line">        return item</span><br><span class="line"></span><br><span class="line">    def item_key(self, item, spider):</span><br><span class="line">        &quot;&quot;&quot;Returns redis key based on given spider.</span><br><span class="line">        Override this function to use a different key depending on the item</span><br><span class="line">        and/or spider.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self.key % &#123;&apos;spider&apos;: spider.name&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>pipelines文件实现了一个item pipieline类，和scrapy的item pipeline是同一个对象，通过从settings中拿到我们配置的<code>REDIS_ITEMS_KEY</code>作为key，把item串行化之后存入redis数据库对应的value中（这个value可以看出出是个list，我们的每个item是这个list中的一个结点），这个pipeline把提取出的item存起来，主要是为了方便我们延后处理数据。</p>
</li>
</ul>
<h2 id="05-源码解读：Queue"><a href="#05-源码解读：Queue" class="headerlink" title="05-源码解读：Queue"></a>05-源码解读：Queue</h2><ul>
<li><p>该文件实现了几个容器类，可以看这些容器和redis交互频繁，同时使用了我们上边picklecompat中定义的序列化器。这个文件实现的几个容器大体相同，只不过一个是队列，一个是栈，一个是优先级队列，这三个容器到时候会被scheduler对象实例化，来实现request的调度。比如我们使用SpiderQueue最为调度队列的类型，到时候request的调度方法就是先进先出，而实用SpiderStack就是先进后出了。</p>
</li>
<li><p>从SpiderQueue的实现看出来，他的push函数就和其他容器的一样，只不过push进去的request请求先被scrapy的接口request_to_dict变成了一个dict对象（因为request对象实在是比较复杂，有方法有属性不好串行化），之后使用picklecompat中的serializer串行化为字符串，然后使用一个特定的key存入redis中（该key在同一种spider中是相同的）。而调用pop时，其实就是从redis用那个特定的key去读其值（一个list），从list中读取最早进去的那个，于是就先进先出了。 这些容器类都会作为scheduler调度request的容器，scheduler在每个主机上都会实例化一个，并且和spider一一对应，所以分布式运行时会有一个spider的多个实例和一个scheduler的多个实例存在于不同的主机上，但是，因为scheduler都是用相同的容器，而这些容器都连接同一个redis服务器，又都使用spider名加queue来作为key读写数据，所以不同主机上的不同爬虫实例公用一个request调度池，实现了分布式爬虫之间的统一调度。</p>
</li>
<li><p>code</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">from scrapy.utils.reqser import request_to_dict, request_from_dict</span><br><span class="line"></span><br><span class="line">from . import picklecompat</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Base(object):</span><br><span class="line">    &quot;&quot;&quot;Per-spider queue/stack base class&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, server, spider, key, serializer=None):</span><br><span class="line">        &quot;&quot;&quot;Initialize per-spider redis queue.</span><br><span class="line">        Parameters:</span><br><span class="line">            server -- redis connection</span><br><span class="line">            spider -- spider instance</span><br><span class="line">            key -- key for this queue (e.g. &quot;%(spider)s:queue&quot;)</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if serializer is None:</span><br><span class="line">            # Backward compatibility.</span><br><span class="line">            # TODO: deprecate pickle.</span><br><span class="line">            serializer = picklecompat</span><br><span class="line">        if not hasattr(serializer, &apos;loads&apos;):</span><br><span class="line">            raise TypeError(&quot;serializer does not implement &apos;loads&apos; function: %r&quot;</span><br><span class="line">                            % serializer)</span><br><span class="line">        if not hasattr(serializer, &apos;dumps&apos;):</span><br><span class="line">            raise TypeError(&quot;serializer &apos;%s&apos; does not implement &apos;dumps&apos; function: %r&quot;</span><br><span class="line">                            % serializer)</span><br><span class="line"></span><br><span class="line">        self.server = server</span><br><span class="line">        self.spider = spider</span><br><span class="line">        self.key = key % &#123;&apos;spider&apos;: spider.name&#125;</span><br><span class="line">        self.serializer = serializer</span><br><span class="line"></span><br><span class="line">    def _encode_request(self, request):</span><br><span class="line">        &quot;&quot;&quot;Encode a request object&quot;&quot;&quot;</span><br><span class="line">        obj = request_to_dict(request, self.spider)</span><br><span class="line">        return self.serializer.dumps(obj)</span><br><span class="line"></span><br><span class="line">    def _decode_request(self, encoded_request):</span><br><span class="line">        &quot;&quot;&quot;Decode an request previously encoded&quot;&quot;&quot;</span><br><span class="line">        obj = self.serializer.loads(encoded_request)</span><br><span class="line">        return request_from_dict(obj, self.spider)</span><br><span class="line"></span><br><span class="line">    def __len__(self):</span><br><span class="line">        &quot;&quot;&quot;Return the length of the queue&quot;&quot;&quot;</span><br><span class="line">        raise NotImplementedError</span><br><span class="line"></span><br><span class="line">    def push(self, request):</span><br><span class="line">        &quot;&quot;&quot;Push a request&quot;&quot;&quot;</span><br><span class="line">        raise NotImplementedError</span><br><span class="line"></span><br><span class="line">    def pop(self, timeout=0):</span><br><span class="line">        &quot;&quot;&quot;Pop a request&quot;&quot;&quot;</span><br><span class="line">        raise NotImplementedError</span><br><span class="line"></span><br><span class="line">    def clear(self):</span><br><span class="line">        &quot;&quot;&quot;Clear queue/stack&quot;&quot;&quot;</span><br><span class="line">        self.server.delete(self.key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SpiderQueue(Base):</span><br><span class="line">    &quot;&quot;&quot;Per-spider FIFO queue&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __len__(self):</span><br><span class="line">        &quot;&quot;&quot;Return the length of the queue&quot;&quot;&quot;</span><br><span class="line">        return self.server.llen(self.key)</span><br><span class="line"></span><br><span class="line">    def push(self, request):</span><br><span class="line">        &quot;&quot;&quot;Push a request&quot;&quot;&quot;</span><br><span class="line">        self.server.lpush(self.key, self._encode_request(request))</span><br><span class="line"></span><br><span class="line">    def pop(self, timeout=0):</span><br><span class="line">        &quot;&quot;&quot;Pop a request&quot;&quot;&quot;</span><br><span class="line">        if timeout &gt; 0:</span><br><span class="line">            data = self.server.brpop(self.key, timeout)</span><br><span class="line">            if isinstance(data, tuple):</span><br><span class="line">                data = data[1]</span><br><span class="line">        else:</span><br><span class="line">            data = self.server.rpop(self.key)</span><br><span class="line">        if data:</span><br><span class="line">            return self._decode_request(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SpiderPriorityQueue(Base):</span><br><span class="line">    &quot;&quot;&quot;Per-spider priority queue abstraction using redis&apos; sorted set&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __len__(self):</span><br><span class="line">        &quot;&quot;&quot;Return the length of the queue&quot;&quot;&quot;</span><br><span class="line">        return self.server.zcard(self.key)</span><br><span class="line"></span><br><span class="line">    def push(self, request):</span><br><span class="line">        &quot;&quot;&quot;Push a request&quot;&quot;&quot;</span><br><span class="line">        data = self._encode_request(request)</span><br><span class="line">        score = -request.priority</span><br><span class="line">        # We don&apos;t use zadd method as the order of arguments change depending on</span><br><span class="line">        # whether the class is Redis or StrictRedis, and the option of using</span><br><span class="line">        # kwargs only accepts strings, not bytes.</span><br><span class="line">        self.server.execute_command(&apos;ZADD&apos;, self.key, score, data)</span><br><span class="line"></span><br><span class="line">    def pop(self, timeout=0):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Pop a request</span><br><span class="line">        timeout not support in this queue class</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # use atomic range/remove using multi/exec</span><br><span class="line">        pipe = self.server.pipeline()</span><br><span class="line">        pipe.multi()</span><br><span class="line">        pipe.zrange(self.key, 0, 0).zremrangebyrank(self.key, 0, 0)</span><br><span class="line">        results, count = pipe.execute()</span><br><span class="line">        if results:</span><br><span class="line">            return self._decode_request(results[0])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SpiderStack(Base):</span><br><span class="line">    &quot;&quot;&quot;Per-spider stack&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __len__(self):</span><br><span class="line">        &quot;&quot;&quot;Return the length of the stack&quot;&quot;&quot;</span><br><span class="line">        return self.server.llen(self.key)</span><br><span class="line"></span><br><span class="line">    def push(self, request):</span><br><span class="line">        &quot;&quot;&quot;Push a request&quot;&quot;&quot;</span><br><span class="line">        self.server.lpush(self.key, self._encode_request(request))</span><br><span class="line"></span><br><span class="line">    def pop(self, timeout=0):</span><br><span class="line">        &quot;&quot;&quot;Pop a request&quot;&quot;&quot;</span><br><span class="line">        if timeout &gt; 0:</span><br><span class="line">            data = self.server.blpop(self.key, timeout)</span><br><span class="line">            if isinstance(data, tuple):</span><br><span class="line">                data = data[1]</span><br><span class="line">        else:</span><br><span class="line">            data = self.server.lpop(self.key)</span><br><span class="line"></span><br><span class="line">        if data:</span><br><span class="line">            return self._decode_request(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__all__ = [&apos;SpiderQueue&apos;, &apos;SpiderPriorityQueue&apos;, &apos;SpiderStack&apos;]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="06-源码解读：Scheduler"><a href="#06-源码解读：Scheduler" class="headerlink" title="06-源码解读：Scheduler"></a>06-源码解读：Scheduler</h2><ul>
<li><p>此扩展是对scrapy中自带的scheduler的替代（在settings的SCHEDULER变量中指出），正是利用此扩展实现crawler的分布式调度。其利用的数据结构来自于queue中实现的数据结构。</p>
</li>
<li><p>scrapy-redis所实现的两种分布式：爬虫分布式以及item处理分布式就是由模块scheduler和模块pipelines实现。上述其它模块作为为二者辅助的功能模块</p>
</li>
<li><p>code</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">import importlib</span><br><span class="line">import six</span><br><span class="line"></span><br><span class="line">from scrapy.utils.misc import load_object</span><br><span class="line"></span><br><span class="line">from . import connection</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># TODO: add SCRAPY_JOB support.</span><br><span class="line">class Scheduler(object):</span><br><span class="line">    &quot;&quot;&quot;Redis-based scheduler&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, server,</span><br><span class="line">                 persist=False,</span><br><span class="line">                 flush_on_start=False,</span><br><span class="line">                 queue_key=&apos;%(spider)s:requests&apos;,</span><br><span class="line">                 queue_cls=&apos;scrapy_redis.queue.SpiderPriorityQueue&apos;,</span><br><span class="line">                 dupefilter_key=&apos;%(spider)s:dupefilter&apos;,</span><br><span class="line">                 dupefilter_cls=&apos;scrapy_redis.dupefilter.RFPDupeFilter&apos;,</span><br><span class="line">                 idle_before_close=0,</span><br><span class="line">                 serializer=None):</span><br><span class="line">        &quot;&quot;&quot;Initialize scheduler.</span><br><span class="line">        Parameters</span><br><span class="line">        ----------</span><br><span class="line">        server : Redis</span><br><span class="line">            The redis server instance.</span><br><span class="line">        persist : bool</span><br><span class="line">            Whether to flush requests when closing. Default is False.</span><br><span class="line">        flush_on_start : bool</span><br><span class="line">            Whether to flush requests on start. Default is False.</span><br><span class="line">        queue_key : str</span><br><span class="line">            Requests queue key.</span><br><span class="line">        queue_cls : str</span><br><span class="line">            Importable path to the queue class.</span><br><span class="line">        dupefilter_key : str</span><br><span class="line">            Duplicates filter key.</span><br><span class="line">        dupefilter_cls : str</span><br><span class="line">            Importable path to the dupefilter class.</span><br><span class="line">        idle_before_close : int</span><br><span class="line">            Timeout before giving up.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if idle_before_close &lt; 0:</span><br><span class="line">            raise TypeError(&quot;idle_before_close cannot be negative&quot;)</span><br><span class="line"></span><br><span class="line">        self.server = server</span><br><span class="line">        self.persist = persist</span><br><span class="line">        self.flush_on_start = flush_on_start</span><br><span class="line">        self.queue_key = queue_key</span><br><span class="line">        self.queue_cls = queue_cls</span><br><span class="line">        self.dupefilter_cls = dupefilter_cls</span><br><span class="line">        self.dupefilter_key = dupefilter_key</span><br><span class="line">        self.idle_before_close = idle_before_close</span><br><span class="line">        self.serializer = serializer</span><br><span class="line">        self.stats = None</span><br><span class="line"></span><br><span class="line">    def __len__(self):</span><br><span class="line">        return len(self.queue)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def from_settings(cls, settings):</span><br><span class="line">        kwargs = &#123;</span><br><span class="line">            &apos;persist&apos;: settings.getbool(&apos;SCHEDULER_PERSIST&apos;),</span><br><span class="line">            &apos;flush_on_start&apos;: settings.getbool(&apos;SCHEDULER_FLUSH_ON_START&apos;),</span><br><span class="line">            &apos;idle_before_close&apos;: settings.getint(&apos;SCHEDULER_IDLE_BEFORE_CLOSE&apos;),</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # If these values are missing, it means we want to use the defaults.</span><br><span class="line">        optional = &#123;</span><br><span class="line">            # TODO: Use custom prefixes for this settings to note that are</span><br><span class="line">            # specific to scrapy-redis.</span><br><span class="line">            &apos;queue_key&apos;: &apos;SCHEDULER_QUEUE_KEY&apos;,</span><br><span class="line">            &apos;queue_cls&apos;: &apos;SCHEDULER_QUEUE_CLASS&apos;,</span><br><span class="line">            &apos;dupefilter_key&apos;: &apos;SCHEDULER_DUPEFILTER_KEY&apos;,</span><br><span class="line">            # We use the default setting name to keep compatibility.</span><br><span class="line">            &apos;dupefilter_cls&apos;: &apos;DUPEFILTER_CLASS&apos;,</span><br><span class="line">            &apos;serializer&apos;: &apos;SCHEDULER_SERIALIZER&apos;,</span><br><span class="line">        &#125;</span><br><span class="line">        for name, setting_name in optional.items():</span><br><span class="line">            val = settings.get(setting_name)</span><br><span class="line">            if val:</span><br><span class="line">                kwargs[name] = val</span><br><span class="line"></span><br><span class="line">        # Support serializer as a path to a module.</span><br><span class="line">        if isinstance(kwargs.get(&apos;serializer&apos;), six.string_types):</span><br><span class="line">            kwargs[&apos;serializer&apos;] = importlib.import_module(kwargs[&apos;serializer&apos;])</span><br><span class="line"></span><br><span class="line">        server = connection.from_settings(settings)</span><br><span class="line">        # Ensure the connection is working.</span><br><span class="line">        server.ping()</span><br><span class="line"></span><br><span class="line">        return cls(server=server, **kwargs)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def from_crawler(cls, crawler):</span><br><span class="line">        instance = cls.from_settings(crawler.settings)</span><br><span class="line">        # FIXME: for now, stats are only supported from this constructor</span><br><span class="line">        instance.stats = crawler.stats</span><br><span class="line">        return instance</span><br><span class="line"></span><br><span class="line">    def open(self, spider):</span><br><span class="line">        self.spider = spider</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            self.queue = load_object(self.queue_cls)(</span><br><span class="line">                server=self.server,</span><br><span class="line">                spider=spider,</span><br><span class="line">                key=self.queue_key % &#123;&apos;spider&apos;: spider.name&#125;,</span><br><span class="line">                serializer=self.serializer,</span><br><span class="line">            )</span><br><span class="line">        except TypeError as e:</span><br><span class="line">            raise ValueError(&quot;Failed to instantiate queue class &apos;%s&apos;: %s&quot;,</span><br><span class="line">                             self.queue_cls, e)</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            self.df = load_object(self.dupefilter_cls)(</span><br><span class="line">                server=self.server,</span><br><span class="line">                key=self.dupefilter_key % &#123;&apos;spider&apos;: spider.name&#125;,</span><br><span class="line">                debug=spider.settings.getbool(&apos;DUPEFILTER_DEBUG&apos;),</span><br><span class="line">            )</span><br><span class="line">        except TypeError as e:</span><br><span class="line">            raise ValueError(&quot;Failed to instantiate dupefilter class &apos;%s&apos;: %s&quot;,</span><br><span class="line">                             self.dupefilter_cls, e)</span><br><span class="line"></span><br><span class="line">        if self.flush_on_start:</span><br><span class="line">            self.flush()</span><br><span class="line">        # notice if there are requests already in the queue to resume the crawl</span><br><span class="line">        if len(self.queue):</span><br><span class="line">            spider.log(&quot;Resuming crawl (%d requests scheduled)&quot; % len(self.queue))</span><br><span class="line"></span><br><span class="line">    def close(self, reason):</span><br><span class="line">        if not self.persist:</span><br><span class="line">            self.flush()</span><br><span class="line"></span><br><span class="line">    def flush(self):</span><br><span class="line">        self.df.clear()</span><br><span class="line">        self.queue.clear()</span><br><span class="line"></span><br><span class="line">    def enqueue_request(self, request):</span><br><span class="line">        if not request.dont_filter and self.df.request_seen(request):</span><br><span class="line">            self.df.log(request, self.spider)</span><br><span class="line">            return False</span><br><span class="line">        if self.stats:</span><br><span class="line">            self.stats.inc_value(&apos;scheduler/enqueued/redis&apos;, spider=self.spider)</span><br><span class="line">        self.queue.push(request)</span><br><span class="line">        return True</span><br><span class="line"></span><br><span class="line">    def next_request(self):</span><br><span class="line">        block_pop_timeout = self.idle_before_close</span><br><span class="line">        request = self.queue.pop(block_pop_timeout)</span><br><span class="line">        if request and self.stats:</span><br><span class="line">            self.stats.inc_value(&apos;scheduler/dequeued/redis&apos;, spider=self.spider)</span><br><span class="line">        return request</span><br><span class="line"></span><br><span class="line">    def has_pending_requests(self):</span><br><span class="line">        return len(self) &gt; 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个文件重写了scheduler类，用来代替scrapy.core.scheduler的原有调度器。其实对原有调度器的逻辑没有很大的改变，主要是使用了redis作为数据存储的媒介，以达到各个爬虫之间的统一调度。 scheduler负责调度各个spider的request请求，scheduler初始化时，通过settings文件读取queue和dupefilters的类型（一般就用上边默认的），配置queue和dupefilters使用的key（一般就是spider name加上queue或者dupefilters，这样对于同一种spider的不同实例，就会使用相同的数据块了）。每当一个request要被调度时，enqueue_request被调用，scheduler使用dupefilters来判断这个url是否重复，如果不重复，就添加到queue的容器中（先进先出，先进后出和优先级都可以，可以在settings中配置）。当调度完成时，next_request被调用，scheduler就通过queue容器的接口，取出一个request，把他发送给相应的spider，让spider进行爬取工作。</p>
</li>
</ul>
<h2 id="07-源码解读：Spider"><a href="#07-源码解读：Spider" class="headerlink" title="07-源码解读：Spider"></a>07-源码解读：Spider</h2><ul>
<li><p>设计的这个spider从redis中读取要爬的url,然后执行爬取，若爬取过程中返回更多的url，那么继续进行直至所有的request完成。之后继续从redis中读取url，循环这个过程。</p>
</li>
<li><p>分析：在这个spider中通过connect signals.spider_idle信号实现对crawler状态的监视。当idle时，返回新的make_requests_from_url(url)给引擎，进而交给调度器调度</p>
</li>
<li><p>code</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">from scrapy import signals</span><br><span class="line">from scrapy.exceptions import DontCloseSpider</span><br><span class="line">from scrapy.spiders import Spider, CrawlSpider</span><br><span class="line"></span><br><span class="line">from . import connection</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Default batch size matches default concurrent requests setting.</span><br><span class="line">DEFAULT_START_URLS_BATCH_SIZE = 16</span><br><span class="line">DEFAULT_START_URLS_KEY = &apos;%(name)s:start_urls&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class RedisMixin(object):</span><br><span class="line">    &quot;&quot;&quot;Mixin class to implement reading urls from a redis queue.&quot;&quot;&quot;</span><br><span class="line">    # Per spider redis key, default to DEFAULT_START_URLS_KEY.</span><br><span class="line">    redis_key = None</span><br><span class="line">    # Fetch this amount of start urls when idle. Default to DEFAULT_START_URLS_BATCH_SIZE.</span><br><span class="line">    redis_batch_size = None</span><br><span class="line">    # Redis client instance.</span><br><span class="line">    server = None</span><br><span class="line"></span><br><span class="line">    def start_requests(self):</span><br><span class="line">        &quot;&quot;&quot;Returns a batch of start requests from redis.&quot;&quot;&quot;</span><br><span class="line">        return self.next_requests()</span><br><span class="line"></span><br><span class="line">    def setup_redis(self, crawler=None):</span><br><span class="line">        &quot;&quot;&quot;Setup redis connection and idle signal.</span><br><span class="line">        This should be called after the spider has set its crawler object.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if self.server is not None:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        if crawler is None:</span><br><span class="line">            # We allow optional crawler argument to keep backwards</span><br><span class="line">            # compatibility.</span><br><span class="line">            # XXX: Raise a deprecation warning.</span><br><span class="line">            crawler = getattr(self, &apos;crawler&apos;, None)</span><br><span class="line"></span><br><span class="line">        if crawler is None:</span><br><span class="line">            raise ValueError(&quot;crawler is required&quot;)</span><br><span class="line"></span><br><span class="line">        settings = crawler.settings</span><br><span class="line"></span><br><span class="line">        if self.redis_key is None:</span><br><span class="line">            self.redis_key = settings.get(</span><br><span class="line">                &apos;REDIS_START_URLS_KEY&apos;, DEFAULT_START_URLS_KEY,</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        self.redis_key = self.redis_key % &#123;&apos;name&apos;: self.name&#125;</span><br><span class="line"></span><br><span class="line">        if not self.redis_key.strip():</span><br><span class="line">            raise ValueError(&quot;redis_key must not be empty&quot;)</span><br><span class="line"></span><br><span class="line">        if self.redis_batch_size is None:</span><br><span class="line">            self.redis_batch_size = settings.getint(</span><br><span class="line">                &apos;REDIS_START_URLS_BATCH_SIZE&apos;, DEFAULT_START_URLS_BATCH_SIZE,</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            self.redis_batch_size = int(self.redis_batch_size)</span><br><span class="line">        except (TypeError, ValueError):</span><br><span class="line">            raise ValueError(&quot;redis_batch_size must be an integer&quot;)</span><br><span class="line"></span><br><span class="line">        self.logger.info(&quot;Reading start URLs from redis key &apos;%(redis_key)s&apos; &quot;</span><br><span class="line">                         &quot;(batch size: %(redis_batch_size)s)&quot;, self.__dict__)</span><br><span class="line"></span><br><span class="line">        self.server = connection.from_settings(crawler.settings)</span><br><span class="line">        # The idle signal is called when the spider has no requests left,</span><br><span class="line">        # that&apos;s when we will schedule new requests from redis queue</span><br><span class="line">        crawler.signals.connect(self.spider_idle, signal=signals.spider_idle)</span><br><span class="line"></span><br><span class="line">    def next_requests(self):</span><br><span class="line">        &quot;&quot;&quot;Returns a request to be scheduled or none.&quot;&quot;&quot;</span><br><span class="line">        use_set = self.settings.getbool(&apos;REDIS_START_URLS_AS_SET&apos;)</span><br><span class="line">        fetch_one = self.server.spop if use_set else self.server.lpop</span><br><span class="line">        # XXX: Do we need to use a timeout here?</span><br><span class="line">        found = 0</span><br><span class="line">        while found &lt; self.redis_batch_size:</span><br><span class="line">            data = fetch_one(self.redis_key)</span><br><span class="line">            if not data:</span><br><span class="line">                # Queue empty.</span><br><span class="line">                break</span><br><span class="line">            req = self.make_request_from_data(data)</span><br><span class="line">            if req:</span><br><span class="line">                yield req</span><br><span class="line">                found += 1</span><br><span class="line">            else:</span><br><span class="line">                self.logger.debug(&quot;Request not made from data: %r&quot;, data)</span><br><span class="line"></span><br><span class="line">        if found:</span><br><span class="line">            self.logger.debug(&quot;Read %s requests from &apos;%s&apos;&quot;, found, self.redis_key)</span><br><span class="line"></span><br><span class="line">    def make_request_from_data(self, data):</span><br><span class="line">        # By default, data is an URL.</span><br><span class="line">        if &apos;://&apos; in data:</span><br><span class="line">            return self.make_requests_from_url(data)</span><br><span class="line">        else:</span><br><span class="line">            self.logger.error(&quot;Unexpected URL from &apos;%s&apos;: %r&quot;, self.redis_key, data)</span><br><span class="line"></span><br><span class="line">    def schedule_next_requests(self):</span><br><span class="line">        &quot;&quot;&quot;Schedules a request if available&quot;&quot;&quot;</span><br><span class="line">        for req in self.next_requests():</span><br><span class="line">            self.crawler.engine.crawl(req, spider=self)</span><br><span class="line"></span><br><span class="line">    def spider_idle(self):</span><br><span class="line">        &quot;&quot;&quot;Schedules a request if available, otherwise waits.&quot;&quot;&quot;</span><br><span class="line">        # XXX: Handle a sentinel to close the spider.</span><br><span class="line">        self.schedule_next_requests()</span><br><span class="line">        raise DontCloseSpider</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class RedisSpider(RedisMixin, Spider):</span><br><span class="line">    &quot;&quot;&quot;Spider that reads urls from redis queue when idle.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def from_crawler(self, crawler, *args, **kwargs):</span><br><span class="line">        obj = super(RedisSpider, self).from_crawler(crawler, *args, **kwargs)</span><br><span class="line">        obj.setup_redis(crawler)</span><br><span class="line">        return obj</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class RedisCrawlSpider(RedisMixin, CrawlSpider):</span><br><span class="line">    &quot;&quot;&quot;Spider that reads urls from redis queue when idle.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def from_crawler(self, crawler, *args, **kwargs):</span><br><span class="line">        obj = super(RedisCrawlSpider, self).from_crawler(crawler, *args, **kwargs)</span><br><span class="line">        obj.setup_redis(crawler)</span><br><span class="line">        return obj</span><br></pre></td></tr></table></figure>
</li>
<li><p>spider的改动也不是很大，主要是通过connect接口，给spider绑定了spider_idle信号，spider初始化时，通过setup_redis函数初始化好和redis的连接，之后通过next_requests函数从redis中取出strat url，使用的key是settings中REDIS_START_URLS_AS_SET定义的（注意了这里的初始化url池和我们上边的queue的url池不是一个东西，queue的池是用于调度的，初始化url池是存放入口url的，他们都存在redis中，但是使用不同的key来区分，就当成是不同的表吧），spider使用少量的start url，可以发展出很多新的url，这些url会进入scheduler进行判重和调度。直到spider跑到调度池内没有url的时候，会触发spider_idle信号，从而触发spider的next_requests函数，再次从redis的start url池中读取一些url。</p>
</li>
</ul>
<h2 id="08-总结"><a href="#08-总结" class="headerlink" title="08-总结"></a>08-总结</h2><ul>
<li>最后总结一下scrapy-redis的总体思路：这个工程通过重写scheduler和spider类，实现了调度、spider启动和redis的交互。实现新的dupefilter和queue类，达到了判重和调度容器和redis的交互，因为每个主机上的爬虫进程都访问同一个redis数据库，所以调度和判重都统一进行统一管理，达到了分布式爬虫的目的。 当spider被初始化时，同时会初始化一个对应的scheduler对象，这个调度器对象通过读取settings，配置好自己的调度容器queue和判重工具dupefilter。每当一个spider产出一个request的时候，scrapy内核会把这个reuqest递交给这个spider对应的scheduler对象进行调度，scheduler对象通过访问redis对request进行判重，如果不重复就把他添加进redis中的调度池。当调度条件满足时，scheduler对象就从redis的调度池中取出一个request发送给spider，让他爬取。当spider爬取的所有暂时可用url之后，scheduler发现这个spider对应的redis的调度池空了，于是触发信号spider_idle，spider收到这个信号之后，直接连接redis读取strart url池，拿去新的一批url入口，然后再次重复上边的工作。</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/python/" rel="tag"># python</a>
          
            <a href="/tags/爬虫/" rel="tag"># 爬虫</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/01/04/Scrapy爬虫框架-1/" rel="next" title="Scrapy爬虫框架-1">
                <i class="fa fa-chevron-left"></i> Scrapy爬虫框架-1
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/04/非结构化数据-结构化数据提取-3/" rel="prev" title="非结构化数据&结构化数据提取-3">
                非结构化数据&结构化数据提取-3 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Ry1ynn">
            
              <p class="site-author-name" itemprop="name">Ry1ynn</p>
              <p class="site-description motion-element" itemprop="description">我们的征途是星辰大海</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">126</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Ry1ynn" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:ry1ynn_pri@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="/images/weixin.JPG" target="_blank" title="Wechat">
                      
                        <i class="fa fa-fw fa-weixin"></i>Wechat</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.t00ls.net/" title="T00ls" target="_blank">T00ls</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.freebuf.com/" title="FreeBuf" target="_blank">FreeBuf</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.sec-wiki.com/" title="SecWiki" target="_blank">SecWiki</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.seebug.org/" title="Seebug" target="_blank">Seebug</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.91ri.org/" title="91Ri" target="_blank">91Ri</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.pediy.com/" title="看雪" target="_blank">看雪</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.52pojie.cn/" title="吾爱破解" target="_blank">吾爱破解</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.anquanke.com/" title="安全客" target="_blank">安全客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.ichunqiu.com/" title="i春秋" target="_blank">i春秋</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#scrapy-shell分布式组件"><span class="nav-text">scrapy-shell分布式组件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#00-简介"><span class="nav-text">00-简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#01-源码解读：Connection"><span class="nav-text">01-源码解读：Connection</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#02-源码解读：Dupefilter"><span class="nav-text">02-源码解读：Dupefilter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#03-源码解读：Picklecompat"><span class="nav-text">03-源码解读：Picklecompat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#04-源码解读：Pipelines"><span class="nav-text">04-源码解读：Pipelines</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#05-源码解读：Queue"><span class="nav-text">05-源码解读：Queue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#06-源码解读：Scheduler"><span class="nav-text">06-源码解读：Scheduler</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#07-源码解读：Spider"><span class="nav-text">07-源码解读：Spider</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#08-总结"><span class="nav-text">08-总结</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ry1ynn</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  










  



  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script id="ribbon" type="text/javascript" size="300" alpha="0.5" zindex="0" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
